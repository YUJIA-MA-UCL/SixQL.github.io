[
  {
    "objectID": "Validation/validation.html",
    "href": "Validation/validation.html",
    "title": "Assessing Urban War Damage in Kharkiv and Mariupol, Ukraine Using Sentinel-1 Imagery",
    "section": "",
    "text": "import pandas as pd\nimport geopandas as gpd\nfrom sklearn.metrics import classification_report, confusion_matrix\nfrom sklearn.metrics import roc_auc_score, roc_curve\n\n\n# ukr1 & ukr7 use the same code but different file path for validation\nukr_all = gpd.read_file(\"./ukr1/1_ukr1_all_footprint/ukr1_all_aoi.geojson\")# all footprint\nukr_gee = gpd.read_file(\"./ukr1/2_ukr1_damaged_ttest/ukr1_final_20220224_12_4_vs_20220512_25.geojson\") # gee results; here is an exaple of ukr1 with 2.5 threshold\nukr_unosat = gpd.read_file(\"./ukr1/3_ukr1_unosat_footprints/ukr1_unosat_damaged_footprint_aoi.geojson\") # unosat damaged footprint; building level\n\n\n# check data\nprint(ukr_all.shape)\nprint(ukr_gee.shape)\nprint(ukr_unosat.shape)\n\n(19688, 10)\n(9724, 11)\n(4953, 10)\n\n\n\n# check crs\nprint(ukr_all.crs)\nprint(ukr_gee.crs)\nprint(ukr_unosat.crs)\n\nEPSG:3857\nEPSG:4326\nEPSG:3857\n\n\n\n# transform crs\nukr_gee = ukr_gee.to_crs(ukr_unosat.crs)\nprint(ukr_gee.crs)\n\nEPSG:3857\n\n\n\n# labels\nukr_all = ukr_all.copy()\n\n# Ground Truth\nukr_all['gt_damaged'] = ukr_all.geometry.apply(\n    lambda geom: ukr_unosat.intersects(geom).any()\n)\n\n# Pred_damaged\nukr_all['pred_damaged'] = ukr_all.geometry.apply(\n    lambda geom: ukr_gee.intersects(geom).any()\n)\n\n\n# define TP FP FN TN\ndef classify(row):\n    if row['gt_damaged'] and row['pred_damaged']:\n        return 'TP'\n    elif not row['gt_damaged'] and row['pred_damaged']:\n        return 'FP'\n    elif row['gt_damaged'] and not row['pred_damaged']:\n        return 'FN'\n    else:\n        return 'TN'\n\nukr_all['confusion'] = ukr_all.apply(classify, axis=1)\n\n# summarize\nconfusion_counts = ukr_all['confusion'].value_counts()\nTP = confusion_counts.get('TP', 0)\nFP = confusion_counts.get('FP', 0)\nFN = confusion_counts.get('FN', 0)\nTN = confusion_counts.get('TN', 0)\n\n\n# Calculate\nprecision = TP / (TP + FP) if (TP + FP) &gt; 0 else 0\nrecall = TP / (TP + FN) if (TP + FN) &gt; 0 else 0\nspecificity = TN / (TN + FP) if (TN + FP) &gt; 0 else 0\naccuracy = (TP + TN) / (TP + FP + FN + TN)\nf1_score = 2 * precision * recall / (precision + recall) if (precision + recall) &gt; 0 else 0\n\n\n# Print results\nprint(f\"TP: {TP}\")\nprint(f\"FP: {FP}\")\nprint(f\"FN: {FN}\")\nprint(f\"TN: {TN}\\n\")\n\nprint(f\"Precision: {precision:.4f}\")\nprint(f\"Recall: {recall:.4f}\")\nprint(f\"Specificity: {specificity:.4f}\")\nprint(f\"Accuracy: {accuracy:.4f}\")\nprint(f\"F1 Score: {f1_score:.4f}\")"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Assessing Urban War Damage in Kharkiv and Mariupol, Ukraine Using Sentinel-1 Imagery",
    "section": "",
    "text": "What is the problem youâ€™re trying to address using this application?\nThis application addresses the need for transparent, cost-effective tools to assess infrastructure damage in urban areas affected by the Russiaâ€“Ukraine war. It focuses on Kharkiv and Mariupol, the two most affected cities, and estimates building and road damage using a lightweight, unsupervised pixel-wise t-test on freely available Sentinel-1 imagery. Although the war is ongoing, our analysis focuses on the year before and after February 24, 2022, when the full-scale invasion began. Unlike deep learning approaches requiring expensive optical imagery, this method supports repeatable, scalable, and interpretable analysis. The results can assist post-war reconstruction planning, guide humanitarian aid, and inform public understanding of urban destruction patterns in these cities.\n\n\n\nWho are you building this application for? How does it address a need this community has?\n\nGovernment and planning departments: Initial analyze damage patterns and damage to specific facilities (e.g.Â housing, hospitals) to prioritise reconstruction and allocate resources effectively.\nHumanitarian organisations: Quickly identify severely damaged areas and assess damage to critical infrastructure and residential areas to provide guidance for emergency shelter, public health and logistics planning.\nRemote sensing and disaster assessment professionals: Use damage data to validate models, track changes, and compare methods or datasets in disaster impact studies.\nPublic and media: Explore clear, visual maps of war damage, thereby raising public awareness, and can provide data to support news reporting.\n\n\n\n\nWhat data are you using?\n\nSentinel-1 Imagery\nThis application uses Sentinel-1 Imagery provided by Google Earth Engine. To simplify processing and prioritize sensitivity to structural damage, only VH-polarized imagery was used. The data spans February 24, 2020 to February 24, 2023, covering placebo, pre-war, and war phases. From February 2022, imagery was compared monthly to capture temporal changes in damage.\nBuilding Footprints\nBuilding footprint data is sourced from the Overture Maps Foundation, which combines several open datasets, primarily from OpenStreetMap, Microsoft, and Google Open Buildings. Buildings smaller than 50 mÂ² were excluded due to potential building false positives and the resolution of Sentinel-1.\nRoad Networks\nThe road network data was retrieved from OpenStreetMap using the OSMnx package in Python, extracting roads classified as trunk, primary, secondary, and tertiary, and simplifying bidirectional edges.\n\n\n\n\nHow are you using this data to address the problem?\nWe used Sentinel-1 SAR imagery to perform a pixel statistical test (t-test) for pre- and post-war changes, identifying potential damage on the map. Overlaying the building footprints and road network data with t-test results to locate and classify damage, and calculate the percentage of damaged buildings and roads, and different subtypes of damaged buildings at 95% confidence intervals. Through monthly monitoring of post-war damages for 12 months after 2022-2-24, the evolution of the war impact will be tracked, and user can select different times to view changes in damages. These features will support urban damage assessment and post-war reconstruction planning.\n\n\n\nHow does your applicationâ€™s interface work to address the needs of your end user?\nThe application provides clear, visual maps of war damage, enabling the public and researchers in remote sensing and disaster assessment to track the evolution of destruction and the recovery process over time. Layer comparison tools help Ukrainian government and humanitarian organizations visually identify specific areas are affected, supporting resource planning and decision-making for wartime relief and post-disaster reconstruction. The application also calculates the proportion of damaged buildings and roads, and visualizes the distribution of damage across different building types, offering reference statistics for researchers. All users can export damaged building GeoJSON data to conduct urban assessments and make data-driven decisions.\n\n\n\n\n\n\n\n\n\n\n\nFull code can be found here.\n\n\nWe imported the vector data, including building footprints with building type information and 7.5-meter-wide rectangular road layers, and merged the data from two cities.\n// ----------------------- Import Data -----------------------  \n// Building footprint\nvar buildings_ukr1 = ee.FeatureCollection(\"projects/ee-yiyaocui/assets/ukr1\");\nvar buildings_ukr7 = ee.FeatureCollection(\"projects/ee-yiyaocui/assets/ukr7\");\nvar buildings = buildings_ukr1.merge(buildings_ukr7);\n\n// Roads\nvar roads_ukr1 = ee.FeatureCollection(\"projects/ee-yiyaocui/assets/osm_ukr1_buffer_50_75_8\")\n  .filterBounds(aoi);\nvar roads_ukr7 = ee.FeatureCollection(\"projects/ee-yiyaocui/assets/osm_ukr7_buffer_50_75_14\")\n  .filterBounds(aoi);\nvar roads = roads_ukr1.merge(roads_ukr7);\nThen, we set up our area of interest (AOI), time range, and mapâ€™s centroids. For time range:\n\nSHOCK_DATE: 2022-02-24, when Russia launched a full-scale military invasion of Ukraine.\nPRE_INTERVAL: 12-month pre-event period (baseline).\nPOST_INTERVAL: 12-month post-event period (all assessment windows).\n\nWe defined a updateDateRanges() function to flexibly select an assessment window for the interactive tool.\n// ----------------------- Set-up  -----------------------\n//AOI\nvar cityBoundaries = ee.FeatureCollection(\"projects/ee-yiyaocui/assets/unosat_aois\")\n  .style({\n    color: 'red', \n    fillColor: '00000000',\n    width: 1 \n  });\nvar aoi = cityBoundaries.geometry();\nvar ukr1 = ee.Geometry.Rectangle([37.46, 47.06, 37.72, 47.16]);\nvar ukr7 = ee.Geometry.Rectangle([36.09, 49.87, 36.46, 50.11]);  \nvar aoi = ee.FeatureCollection([\n  ee.Feature(ukr1),\n  ee.Feature(ukr7)\n]).merge(ee.FeatureCollection([])).geometry();\n\n//Time \nvar SHOCK_DATE = \"2022-02-24\";\nvar PRE_INTERVAL = 12;  // month before the event\nvar POST_INTERVAL = 12; // month after the event\n// Calculate precise data filtering range, recalculate when POST_INTERVAL changes\nfunction updateDateRanges() {\n  var startDate = ee.Date(SHOCK_DATE).advance(-PRE_INTERVAL, \"month\").format(\"YYYY-MM-dd\");\n  var endDate = ee.Date(SHOCK_DATE).advance(POST_INTERVAL, \"month\").format(\"YYYY-MM-dd\");\n  return {startDate: startDate, endDate: endDate};\n}\n// Initialize date range\nvar dateRanges = updateDateRanges();\nvar startDate = dateRanges.startDate;\nvar endDate = dateRanges.endDate; \n\n// Centroid\nMap.centerObject(cityBoundaries, 8);\n\n// Centroid of mariupol \nvar mariupolCenter = ee.Geometry.Point([37.59269, 47.09966]);\nMap.centerObject(mariupolCenter, 14);\n\n\n\nBased on the tutorial code from CASA0025 Week 9 (Ballinger, O., 2024), we used the following equation to compute the t-value for each pixel, comparing radar backscatter values before and after the war:\n\\[ \\Large t = {\\frac{\\overline{x_1}-\\overline{x_2}} {\\sqrt{\\frac{s^2_1}{n_1} + \\frac{s^2_2}{n_2}}}} \\]\nWhere:\n\n\\(\\overline{x_1}\\)ï¼šmean of the pre-war imagery // code variables: pre-mean\n\\(\\overline{x_2}\\)ï¼šmean of the post-war imagery // code variables: post_mean\n\\(s_1^2, s_2^2\\)ï¼švariance of the pre- and post-war data // code variables: pre_sd, post_sd; \\(s^2\\) is implied as \\(sd^2\\)\n\\(n_1, n_2\\)ï¼šnumber of images before and after the war // code variables: pre_n, post_n\n\nThis approach helps quantify whether observed changes are statistically significant and is particularly useful when ground-truth data is limited. Finally, a t-value greater than 2.5 indicates a significant change at the 99% confidence level.\n// ----------------------- TTest function  -----------------------\n// t-test function (building analysis)\nfunction ttest(s1, shock, pre_interval, post_interval) {\n  // Convert event date to ee.Date object\n  var shock = ee.Date(shock);\n  // Filter pre-event images: from (shock - pre_interval months) to shock\n  var pre = s1.filterDate(\n    shock.advance(ee.Number(pre_interval).multiply(-1), \"month\"),\n    shock\n  );\n  // Filter post-event images: from shock to (shock + post_interval months)\n  var post = s1.filterDate(shock, shock.advance(post_interval, \"month\"));\n  // Calculate pre-event mean, standard deviation, and image count\n  var pre_mean = pre.mean();\n  var pre_sd = pre.reduce(ee.Reducer.stdDev());\n  var pre_n = ee.Number(pre.filterBounds(aoi).size());\n  // Calculate post-event mean, standard deviation, and image count\n  var post_mean = post.mean();\n  var post_sd = post.reduce(ee.Reducer.stdDev());\n  var post_n = ee.Number(post.filterBounds(aoi).size());\n  // Print pre and post event image counts for debugging\n  print('Pre-event images count: ', pre_n);\n  print('Post-event images count: ', post_n);\n  // Calculate pooled standard deviation\n  var pooled_sd = pre_sd\n    .multiply(pre_sd)\n    .multiply(pre_n.subtract(1))\n    .add(post_sd.multiply(post_sd).multiply(post_n.subtract(1)))\n    .divide(pre_n.add(post_n).subtract(2))\n    .sqrt();\n  // Calculate denominator part of t-test formula\n  var denom = pooled_sd.multiply(\n    ee.Number(1).divide(pre_n).add(ee.Number(1).divide(post_n)).sqrt()\n  );\n  // Calculate degrees of freedom (number of observations minus 2)\n  var df = pre_n.add(post_n).subtract(2);\n  print(\"Number of Images: \", df);\n  // Calculate t-value: absolute difference of means divided by denominator, minus 2\n  var change = post_mean\n    .abs()\n    .subtract(pre_mean.abs())\n    .divide(denom)\n    .abs()\n    .subtract(2.5);\n   \n  // Return t-value for each pixel\n  return change;\n}\nWe filter Sentinel-1 radar images by selecting the VH polarization band and the most common orbit number, then separately process ASCENDING and DESCENDING orbits to reduce directional noise. Also, we use NDVI to reduce vegetation disturbance (NDVI &gt; 0.2: vegetation)(Wang, X.&Li, P., 2020; USGS,2018).\n// ----------------------- Satellite Image -----------------------\n// Select Sentinel 1 images collection for analysis\nfunction filter_s1(path) {\n  var s1 = ee\n    .ImageCollection(\"COPERNICUS/S1_GRD\")\n    .filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VH\"))\n    .filter(ee.Filter.eq(\"instrumentMode\", \"IW\"))\n    .filter(ee.Filter.eq(\"orbitProperties_pass\", path))\n    .filterBounds(aoi)\n    .filterDate(startDate, endDate)\n    .select(\"VH\");\n\n  var orbit = s1\n    .aggregate_array(\"relativeOrbitNumber_start\")\n    .reduce(ee.Reducer.mode());\n\n  s1 = s1.filter(ee.Filter.eq(\"relativeOrbitNumber_start\", orbit));\n\n  // Return change in t-value\n  var change = ttest(s1, SHOCK_DATE, PRE_INTERVAL, POST_INTERVAL)\n  return change;\n}\n\n// Select sentinel image for calculation\nvar ascending_image = filter_s1(\"ASCENDING\");\nvar descending_image = filter_s1(\"DESCENDING\");\nvar asc_des = ee.ImageCollection([ascending_image, descending_image])\n  .median() // use median to reduce impacts of outliers\n  .clip(aoi);\n\n// Add NDVI Mask\nvar s2 = ee.ImageCollection('COPERNICUS/S2_SR')\n  .filterDate(startDate, SHOCK_DATE)\n  .filterBounds(aoi)\n  .select(['B4','B8'])\n  .median(); \nvar ndvi = s2.normalizedDifference(['B8','B4']).rename('NDVI');\nvar ndvi_mask = ndvi.gt(0.2);\n\n// Generate Composite Image\nvar composite_image = asc_des.where(ndvi_mask, 0);\nThen we overlay the t-test output with building and road layers to estimate the number of damaged buildings and roads in each city. As roads are sensitive to neighboring pixels, we defined damaged roads with at least 50% significant pixels.\n// ----------------------- Analysis -----------------------\n\n// Select significant pixel where t-value is positive (99% confidence interval)\nvar threshold = composite_image.updateMask(composite_image.gt(0));\n\n// Detect damaged buildings and roads\nvar damaged_building = threshold.reduceRegions({\n  collection: buildings,\n  reducer: ee.Reducer.mean(),\n  scale: 10\n});\n\nvar damaged_roads = threshold.reduceRegions({\n  collection: roads,\n  reducer: ee.Reducer.mean(),\n  scale: 10\n});\n\n// ----------------------- Calculation -----------------------\n// Calculate the number of damaged buildings/roads by cities \n//Buildings\nvar mariupol_buildings = damaged_building.filterBounds(ukr1).filter(ee.Filter.gt(\"mean\", 0));\nvar kharkiv_buildings = damaged_building.filterBounds(ukr7).filter(ee.Filter.gt(\"mean\", 0));\nvar total_buildings = mariupol_buildings.merge(kharkiv_buildings);\n\n//Roads\nvar mariupol_roads = damaged_roads.filterBounds(ukr1).filter(ee.Filter.gt(\"mean\", 0.5));\nvar kharkiv_roads = damaged_roads.filterBounds(ukr7).filter(ee.Filter.gt(\"mean\", 0.5));\nvar total_roads = mariupol_roads.merge(kharkiv_roads);\n\n// ----------------------- Visualization -----------------------\n// Define color palettes for damaged buildings and roads\nvar palette = [\"FFFFFF\", \"3b528b\", \"21918c\", \"5ec962\", \"fde725\"];\nvar building_palette = [\"FFF3D6\", \"FFDD9E\", \"FFBE66\", \"FF9A3D\", \"FF7519\", \"FF5100\", \"FD3000\"]; \n\n// ----------------------- Layers -----------------------\n//ttest\nMap.addLayer(\n  composite_image,\n  { min: 0, max: 4, opacity: 0.8, palette: palette },\n  \"Buildings Change\",\n  false  // Not displayed by default\n);\n\n// Building Footprint Outline\nvar empty_buildings = ee.Image().byte();\nvar buildings_outline = empty_buildings.paint({\n  featureCollection: damaged_building,\n  color: \"mean\",\n  width: 1.5\n});\n\n// Draw road outline - add white border\nvar empty_roads = ee.Image().byte();\n\n// First create a wider white border\nvar roads_white_outline = empty_roads.paint({\n  featureCollection: damaged_roads,\n  color: 1,  // White\n  width: 9   // Wider than normal width to form a border\n});\n\n// Then create normal width colored roads\nvar roads_outline = empty_roads.paint({\n  featureCollection: damaged_roads,\n  color: \"mean\",\n  width: 5\n});\n\n//  Mapping for checking but displayed by default for user interface design \n// Add building outline layer\nMap.addLayer(\n  buildings_outline,\n  { palette: building_palette, min: 0.6, max: 2 },\n  \"Damaged Buildings\",\n  true  // Displayed by default\n);\n\n// First add white border layer\nMap.addLayer(\n  roads_white_outline,\n  { palette: [\"ffffff\"], min: 0, max: 1 },\n  \"Roads White Outline\",\n  false  // Not displayed by default\n);\n// Then add colored road layer\nMap.addLayer(\n  roads_outline,\n  { palette: building_palette, min: 0.6, max: 2 },\n  \"Damaged Roads\",\n  false  // Not displayed by default\n);\n\n// Add city boundary layer\nMap.addLayer(cityBoundaries, {}, 'adminboundaries');\n\n\n\n\n\n\nColor Icon\nColor Name\nDamage Level\n\n\n\n\nðŸ”µ\nBlue\nNo damage\n\n\nðŸŸ¢\nGreen\nLow damage\n\n\nðŸŸ¡ðŸŸ \nYellow / Orange\nMedium damage\n\n\nðŸ”´\nRed\nHigh levels of damage\n\n\n\n\n\n \nThe placebo test showed cumulative natural disturbances, stronger and seasonal in Kharkiv, and mainly industrial in Mariupol, with visible improvement after vegetation removal.\n\n\n\nIn the t-test evaluations, our method effectively identified large-scale damage to buildings and roads, supported by the prior separation of built-up areas from open green spaces.\n \nIn Area A, structural damage was accurately detected without interference from surrounding vegetation; in Area B, major building footprint damage was captured with slight spatial overflow; and in Area C, gaps between adjacent row houses were clearly distinguished. On roads, the model correctly detected heavily damaged sections alongside buildings in Area D, but misclassified a functioning road in Area E as moderately damaged.\n\n\n\nIn addition, we compared our outcome to UNOSAT Ground truth datasets to validate the modelâ€™s performance to detect damaged buildings by spatially interactive matching. (UNOSAT, cited in Dietrich et al., 2025)\n##### Results\nTable 1: Mariupol with 99% confidence interval\n\n\n\nMetric\nValue\n\n\n\n\nTP (True Positive)\n3362\n\n\nFP (False Positive)\n5800\n\n\nFN (False Negative)\n1831\n\n\nTN (True Negative)\n8695\n\n\nPrecision\n0.3670\n\n\nRecall\n0.6474\n\n\nSpecificity\n0.5999\n\n\nAccuracy\n0.6124\n\n\nF1 Score\n0.4684\n\n\n\n\nTable 2: Mariupol with 95% confidence interval\n\n\n\nMetric\nValue\n\n\n\n\nTP (True Positive)\n3908\n\n\nFP (False Positive)\n7932\n\n\nFN (False Negative)\n1285\n\n\nTN (True Negative)\n6563\n\n\nPrecision\n0.3301\n\n\nRecall\n0.7526\n\n\nSpecificity\n0.4528\n\n\nAccuracy\n0.5318\n\n\nF1 Score\n0.4589\n\n\n\n\nTable 3: Kharkiv with 99% confidence interval\n\n\n\nMetric\nValue\n\n\n\n\nTP (True Positive)\n689\n\n\nFP (False Positive)\n57286\n\n\nFN (False Negative)\n182\n\n\nTN (True Negative)\n58532\n\n\nPrecision\n0.0119\n\n\nRecall\n0.7910\n\n\nSpecificity\n0.5054\n\n\nAccuracy\n0.5075\n\n\nF1 Score\n0.0234\n\n\n\n\nTable 4: Kharkiv with 95% confidence interval\n\n\n\nMetric\nValue\n\n\n\n\nTP (True Positive)\n751\n\n\nFP (False Positive)\n72650\n\n\nFN (False Negative)\n120\n\n\nTN (True Negative)\n43168\n\n\nPrecision\n0.0102\n\n\nRecall\n0.8622\n\n\nSpecificity\n0.3727\n\n\nAccuracy\n0.3764\n\n\nF1 Score\n0.0202\n\n\n\nConclusively, using a 99% confidence interval improved predictive performance. In Mariupol, the F1 score reached 0.4684, demonstrating reasonable effectiveness, while Kharkivâ€™s F1 score remained low at 0.0234.\nPerformance limitations were likely linked to natural disturbances, pixel spill-over effects caused by the resolution constraints of 10-metre imagery, temporal mismatches with manual labels due to the cumulative nature of warfare destruction and unclear damage definitions, and missing road footprint and subtype data.\nWhile the method remains valuable for preliminary screening by international organisations, future improvements should prioritize refined preprocessing, clearer damage definitions, multi-temporal validation, and the potential integration of supervised learning techniques to enhance overall accuracy.\n\n\n\n\nThe following part is the code for UI design.\n// ------------------------------------- USER INTERFACE -------------------------------------\n\n// Create left control panel\nvar leftPanel = ui.Panel({\n  style: {\n    position: 'top-left',\n    minWidth: '290px',\n    width: '22%',\n    maxWidth: '500px',\n    maxHeight: '88%',\n    height: 'auto'\n  },\n  layout: ui.Panel.Layout.flow('vertical', true)\n});\n\n// Title panel\nvar titlePanel = ui.Panel([\n  ui.Label('Ukraine Buildings and Roads Damage Assessment', {\n    fontWeight: 'bold',\n    fontSize: '20px'\n  }),\n  ui.Label('Assessing Urban War Damage in Kharkiv and Mariupol, Ukraine Using Sentinel-1 Imagery')\n]);\n\n// Add separator line\nvar lineBreak = ui.Panel({\n  style: {\n    stretch: 'horizontal',\n    height: '1px',\n    backgroundColor: '000',\n    margin: '8px 0px 8px 0px'\n  }\n});\n\n// Set Mariupol and Kharkiv city center coordinates\nvar mariupolCenter = ee.Geometry.Point([37.59269, 47.09966]);\nvar kharkivCenter = ee.Geometry.Point([36.232845, 49.988358]);\n\n// Create city selection dropdown\nvar citySelect = ui.Select({\n  items: ['Mariupol','Kharkiv'],\n  value: 'Mariupol',\n  onChange: function(value) {\n    if (value === 'Kharkiv') {\n      Map.centerObject(kharkivCenter, 13);\n    } else if (value === 'Mariupol') {\n      Map.centerObject(mariupolCenter, 14);\n    }\n  },\n  style: {stretch: 'horizontal', textAlign: 'center'}\n});\n\n\nvar cityPanel = ui.Panel([\n  ui.Label('Select City', {\n    textAlign: 'center',\n    fontSize: '16px',\n    fontWeight: 'bold'\n  }),\n  citySelect\n])\n\n\n// create a time selection panel\nvar timePanel = ui.Panel({\n  layout: ui.Panel.Layout.flow('vertical'),\n  style: {padding: '5px 0'}\n});\n\ntimePanel.add(ui.Label('Select Time Period', {\n  fontSize: '16px',\n  fontWeight: 'bold',\n  textAlign: 'center'\n}));\n\n// create a start date information (fixed value)\nvar formattedStartDate = ee.Date(SHOCK_DATE).format('YYYY-MM-dd').getInfo();\ntimePanel.add(ui.Label('Start Date:' + formattedStartDate +' (Fixed)', {\n  textAlign: 'left'\n}));\n\n// create a date picker to select a time interval\nvar endDateLabel = ui.Label('End Date:', {\n  textAlign: 'left'\n});\ntimePanel.add(endDateLabel);\n\n// set up the month interval options\nvar intervalOptions = [\n  {label: '1 months (2022-03-24)', value: 1},\n  {label: '2 months (2022-04-24)', value: 2},\n  {label: '3 months (2022-05-24)', value: 3},\n  {label: '4 months (2022-06-24)', value: 4},\n  {label: '5 months (2022-07-24)', value: 5},\n  {label: '6 months (2022-08-24)', value: 6},\n  {label: '7 months (2022-09-24)', value: 7},\n  {label: '8 months (2022-10-24)', value: 8},\n  {label: '9 months (2022-11-24)', value: 9},\n  {label: '10 months (2022-12-24)', value: 10},\n  {label: '11 months (2023-01-24)', value: 11},\n  {label: '12 months (2023-02-24)', value: 12}\n];\n\n// create a time interval selection drop-down box\n// default set the POST_INTERVAL to 1, to compare with the first month\nvar POST_INTERVAL = 1;\nvar intervalSelect = ui.Select({\n  items: intervalOptions,\n  value: POST_INTERVAL,\n  onChange: function(value) {\n    POST_INTERVAL = Number(value);\n    reanalyzeWithNewInterval();\n    // update the left map\n    copyLayersToLeftMap();\n    // update the right map\n    setRightMapLayers();\n  },\n  style: {stretch: 'horizontal'}\n});\n\ntimePanel.add(intervalSelect);\n\ntimePanel.add(ui.Label('Select different time periods to view the evolution of war impacts on cities', {\n  fontSize: '11px'\n}));\n\n// -------------------------------------\n// Layer control panel\nvar layerPanel = ui.Panel({\n  widgets: [\n    ui.Label('Select Layers', {\n      fontSize: '16px',\n      fontWeight: 'bold'\n    })\n  ],\n  layout: ui.Panel.Layout.flow('vertical', false),  // Set to false to disable scrollbar\n  style: {padding: '0px', margin: '0px', maxHeight: 'none'}  // Ensure no height limit\n});\n\n// Get layer by specific name\nfunction getLayerByName(name) {\n  var layers = Map.layers().getJsArray();\n  for (var i = 0; i &lt; layers.length; i++) {\n    if (layers[i].getName() === name) {\n      return layers[i];\n    }\n  }\n  return null;\n}\n\n// Create layer checkboxes\nvar buildingsCheckbox = ui.Checkbox({\n  label: 'Buildings',\n  value: true,  // Selected by default\n  onChange: function(isChecked) {\n    // Use name to find layer instead of index\n    var layer = getLayerByName(\"Damaged Buildings\");\n    if (layer) {\n      layer.setShown(isChecked);\n    }\n  }\n});\n\nvar roadsCheckbox = ui.Checkbox({\n  label: 'Roads',\n  value: false,  // Not selected by default\n  onChange: function(isChecked) {\n    // Control both road layers simultaneously\n    var whiteOutline = getLayerByName(\"Roads White Outline\");\n    var roads = getLayerByName(\"Damaged Roads\");\n    \n    if (whiteOutline) {\n      whiteOutline.setShown(isChecked);\n    }\n    \n    if (roads) {\n      roads.setShown(isChecked);\n    }\n  }\n});\n\nvar ttestCheckbox = ui.Checkbox({\n  label: 'T-test Result',\n  value: false,  // Not selected by default\n  onChange: function(isChecked) {\n    var layer = getLayerByName(\"T-test Result\");\n    if (layer) {\n      layer.setShown(isChecked);\n    }\n  }\n});\n\n// Create a horizontal layout panel to contain checkboxes\nvar checkboxPanel = ui.Panel({\n  widgets: [buildingsCheckbox, roadsCheckbox, ttestCheckbox],\n  layout: ui.Panel.Layout.flow('horizontal'),\n  style: {stretch: 'horizontal', margin: '4px 0px'}\n});\n\n// Add checkbox horizontal panel to layer control panel\nlayerPanel.add(checkboxPanel);\n\n// Create an empty row as separator\nlayerPanel.add(ui.Label('', {margin: '8px 0px'}));\n\n// Create legend function\nfunction createColorBarPanel() {\n  // Define color array\n  var colors = [\"FFF3D6\", \"FFDD9E\", \"FFBE66\", \"FF9A3D\", \"FF7519\", \"FF5100\", \"FD3000\"];\n  // Create color bar parameters\n  function makeColorBarParams(palette) {\n    return {\n      bbox: [0, 0, 1, 0.1],\n      dimensions: \"100x10\",\n      format: \"png\",\n      min: 0,\n      max: 1,\n      palette: palette,\n    };\n  }\n  \n  // Create legend title\n  var colorBarTitle = ui.Label({\n    value: \"Damage Probability\",\n    style: { fontWeight: \"bold\", textAlign: \"center\", stretch: \"horizontal\"},\n  });\n  \n  // Create color bar\n  var colorBar = ui.Thumbnail({\n    image: ee.Image.pixelLonLat().select(0),\n    params: makeColorBarParams(colors),\n    style: { stretch: \"horizontal\", margin: \"0px 8px\", maxHeight: \"24px\" },\n  });\n  \n  // Create legend labels\n  var colorBarLabels = ui.Panel({\n    widgets: [\n      ui.Label('Low', { margin: \"4px 8px\" }),\n      ui.Label(\" \", {\n        margin: \"4px 8px\",\n        textAlign: \"center\",\n        stretch: \"horizontal\",\n      }),\n      ui.Label('High', { margin: \"4px 8px\" }),\n    ],\n    layout: ui.Panel.Layout.flow(\"horizontal\"),\n  });\n  \n  // Combine all elements\n  var colorBarPanel = ui.Panel({\n    widgets: [colorBarTitle, colorBar, colorBarLabels],\n    style: {stretch: 'horizontal', margin: \"0px 0px 8px 0px\"}\n  });\n  \n  return colorBarPanel;\n}\n\n// Add color legend to layer panel\nlayerPanel.add(createColorBarPanel());\n\n// -------------------------------------\n// Create assessment panel\nvar assessPanel = ui.Panel({\n  layout: ui.Panel.Layout.flow('vertical'),\n  style: {padding: '5px 0', margin: '5px 0'}\n});\n\n// Add title\nassessPanel.add(ui.Label('Calculate Damaged Buildings and Roads', {\n  fontSize: '16px',\n  fontWeight: 'bold'\n}));\n\n// Create results display area\nvar resultsPanel = ui.Panel({\n  layout: ui.Panel.Layout.flow('vertical'),\n  style: {\n    margin: '8px 0px',\n    padding: '8px',\n    border: '1px solid #cccccc',\n    fontSize: '13px'\n  }\n});\nresultsPanel.add(ui.Label('Select a city and click Calculate button to view damage assessment.'));\n\n// Create button panel (horizontal layout)\nvar buttonPanel = ui.Panel({\n  layout: ui.Panel.Layout.flow('horizontal'),\n  style: {stretch: 'horizontal', margin: '5px 0'}\n});\n\n// Create calculate button\nvar calculateButton = ui.Button({\n  label: 'Calculate',\n  onClick: function() {\n    calculateDamage();\n  },\n  style: {\n    stretch: 'horizontal',\n    textAlign: 'center',\n    margin: '5px 2px 5px 0'\n  }\n});\n\n// Create reset button\nvar resetButton = ui.Button({\n  label: 'Reset',\n  onClick: function() {\n    updateResultsPanel();\n  },\n  style: {\n    stretch: 'horizontal',\n    textAlign: 'center',\n    margin: '5px 0 5px 2px'\n  }\n});\n\n// Add buttons to button panel\nbuttonPanel.add(calculateButton);\nbuttonPanel.add(resetButton);\n\n// Add button panel and results panel\nassessPanel.add(buttonPanel);\nassessPanel.add(resultsPanel);\n\n// Results displayed in assessment panel\nfunction updateResultsPanel() {\n  try {\n    // Convert EE object to JavaScript string (for UI display)\n    var formattedEndDate = ee.Date(SHOCK_DATE).advance(POST_INTERVAL, \"month\").format('YYYY-MM-dd').getInfo();\n    \n    // Clear results panel\n    resultsPanel.clear();\n    resultsPanel.add(ui.Label('Select a city and click Calculate button to view damage assessment.'));\n  } catch (e) {\n    print('Error updating results panel:', e);}\n}\n\n// Calculate damage\nfunction calculateDamage() {\n  // Get currently selected city\n  var selectedCity = citySelect.getValue();\n  \n  // Clear results panel and show calculating status\n  resultsPanel.clear();\n  resultsPanel.add(ui.Label('Calculating...', {\n    color: '#0034f5'\n  }));\n  \n  // Force UI to render first, then execute calculation using ee.Number's evaluate method\n  ee.Number(1).evaluate(function() {\n    // Convert EE object to JavaScript string (for UI display)\n    var formattedEndDate;\n    try {\n      formattedEndDate = ee.Date(SHOCK_DATE).advance(POST_INTERVAL, \"month\").format('YYYY-MM-dd').getInfo();\n    } catch (e) {\n      formattedEndDate = \"Error: Could not format date\";\n      print(\"Error formatting end date:\", e);\n    }\n    \n    // Get corresponding AOI based on selected city\n    var cityAOI;\n    if (selectedCity === 'Mariupol') {\n      cityAOI = ukr1;\n    } else if (selectedCity === 'Kharkiv') {\n      cityAOI = ukr7;\n    }\n    \n    try {\n      // Filter buildings and roads for current city\n      var city_buildings = damaged_building.filterBounds(cityAOI).filter(ee.Filter.gt(\"mean\", 0));\n      var city_roads = damaged_roads.filterBounds(cityAOI).filter(ee.Filter.gt(\"mean\", 0));\n      \n      // Calculate totals and proportions\n      // Get total building count for this city (by querying original building data)\n      var total_city_buildings = buildings.filterBounds(cityAOI);\n      var total_city_roads = roads.filterBounds(cityAOI);\n      \n      // get data on damaged buildings and road\n      var damaged_buildings_count = city_buildings.size().getInfo();\n      var total_buildings_count = total_city_buildings.size().getInfo();\n      var damaged_roads_count = city_roads.size().getInfo();\n      var total_roads_count = total_city_roads.size().getInfo();\n      \n      // calculate the percentage of damaged buildings by subtype\n      var buildings_percentage = (damaged_buildings_count / total_buildings_count * 100).toFixed(2);\n      var roads_percentage = (damaged_roads_count / total_roads_count * 100).toFixed(2);\n      var countsDict = ee.Dictionary(city_buildings.aggregate_histogram('subtype'));\n      var subtypeTable = ee.FeatureCollection(\n        countsDict.keys().map(function(k){\n          k = ee.String(k);\n          var n = ee.Number(countsDict.get(k));\n          return ee.Feature(null, {\n            label : k.cat(' (').cat(n.format()).cat(')'),\n            count : n\n          });\n        }));\n      \n      // draw a piechart for damaged building subtype\n      var damagePie = ui.Chart.feature.byFeature(subtypeTable, 'label', ['count']).setChartType('PieChart')\n      .setOptions({\n        pieHole: 0.4,\n        pieSliceText: 'lable',\n        legend: {position: 'bottom',\n        alignment:  'center',\n        textStyle:  {fontSize: 14},\n        maxLines:3},\n        colors:['#0969a2','#ffc700','#ff4e40','#03436a','#ffe073','#ff1300','#245a7a','#ffd540',\n        '#d1b9c2','ff7d73','#64a8d1','bf3a30']\n      });\n      \n      // clear and display results\n      resultsPanel.clear();\n      resultsPanel.add(ui.Label('City:  ',{fontWeight: 'bold'}));\n      resultsPanel.add(ui.Label(selectedCity));\n      resultsPanel.add(ui.Label('Time Period:',{fontWeight: 'bold'}));\n      resultsPanel.add(ui.Label('2022-02-24 to ' + formattedEndDate));\n      resultsPanel.add(ui.Label('Damaged Buildings: ',{fontWeight: 'bold'}));\n      resultsPanel.add(ui.Label(damaged_buildings_count + ' out of ' + total_buildings_count + ' (' + buildings_percentage + '%)'));\n      resultsPanel.add(ui.Label('Damaged Roads: ',{fontWeight: 'bold'}));\n      resultsPanel.add(ui.Label(damaged_roads_count + ' out of ' + total_roads_count + ' (' + roads_percentage + '%)'));\n      resultsPanel.add(ui.Label('Building damage statistics (by building type):',{fontWeight: 'bold'}));\n      resultsPanel.add(damagePie);\n      \n    } catch (e) {\n      // display error messages when errors occur\n      resultsPanel.clear();\n      resultsPanel.add(ui.Label('Error calculating results: ' + e.message, {\n        color: 'red',\n        fontWeight: 'bold'\n      }));\n      print('Error in damage calculation:', e);\n    }\n  });\n}\n\n// Reanalyze with new POST_INTERVAL\nfunction reanalyzeWithNewInterval() {\n  // Clear console\n  //print('Reanalyzing: ' + POST_INTERVAL + ' months of war impact');\n  \n  // Update date range\n  var newDateRanges = updateDateRanges();\n  startDate = newDateRanges.startDate;\n  endDate = newDateRanges.endDate;\n  \n  //print('Analysis period: from ' + startDate + ' to ' + endDate);\n  \n  // Clear existing layers on map\n  while (Map.layers().length() &gt; 0) {\n    Map.layers().remove(Map.layers().get(0));\n  }\n  \n  // Recalculate building and road changes\n  var ascending_image = filter_s1(\"ASCENDING\");\n  var descending_image = filter_s1(\"DESCENDING\");\n  \nvar asc_des = ee.ImageCollection([ascending_image, descending_image])\n.median()\n.clip(aoi);\n\n// Add NDVI Mask\nvar s2 = ee.ImageCollection('COPERNICUS/S2_SR')\n.filterDate(startDate, SHOCK_DATE)\n.filterBounds(aoi)\n.select(['B4','B8'])\n.median();\nvar ndvi = s2.normalizedDifference(['B8','B4']).rename('NDVI');\nvar ndvi_mask = ndvi.gt(0.2);\n\n// Generate Composite Image\nvar composite_image = asc_des.where(ndvi_mask, 0);\n\n  // Create building change mask (95% confidence)\n  var threshold = composite_image.updateMask(composite_image.gt(0));\n\n  // Analyze building changes\n  damaged_building = threshold.reduceRegions({\n    collection: buildings,\n    reducer: ee.Reducer.mean(),\n    scale: 10\n  });\n\n  // Analyze road changes\n  damaged_roads = threshold.reduceRegions({\n    collection: roads,\n    reducer: ee.Reducer.mean(),\n    scale: 10\n  });\n  \n  // Number of affected buildings and roads\n  var mariupol_buildings = damaged_building.filterBounds(ukr1).filter(ee.Filter.gt(\"mean\", 0));\n  var kharkiv_buildings = damaged_building.filterBounds(ukr7).filter(ee.Filter.gt(\"mean\", 0));\n  var total_buildings = mariupol_buildings.merge(kharkiv_buildings);\n\n  var mariupol_roads = damaged_roads.filterBounds(ukr1).filter(ee.Filter.gt(\"mean\", 0.5));\n  var kharkiv_roads = damaged_roads.filterBounds(ukr7).filter(ee.Filter.gt(\"mean\", 0.5));\n  var total_roads = mariupol_roads.merge(kharkiv_roads);\n  \n  print(\"mariupol - damaged buildings:\", mariupol_buildings.size());\n  print(\"kharkiv - damaged buildings:\", kharkiv_buildings.size());\n  print(\"total - damaged buildings:\", total_buildings.size());\n  print(\"mariupol - damaged roads:\", mariupol_roads.size());\n  print(\"kharkiv - damaged roads:\", kharkiv_roads.size());\n  print(\"total - damaged roads:\", total_roads.size());\n  \n  // Draw building outlines\n  var empty_buildings = ee.Image().byte();\n  var buildings_outline = empty_buildings.paint({\n    featureCollection: damaged_building,\n    color: \"mean\",\n    width: 1.5\n  });\n\n  // Draw road outlines - add white border\n  var empty_roads = ee.Image().byte();\n  var roads_white_outline = empty_roads.paint({\n    featureCollection: damaged_roads,\n    color: 1,\n    width: 9\n  });\n  var roads_outline = empty_roads.paint({\n    featureCollection: damaged_roads,\n    color: \"mean\",\n    width: 5\n  });\n  \n  // Add layers\n  Map.addLayer(\n    composite_image,\n    { min: 0, max: 4, opacity: 0.8, palette: palette },\n    \"T-test Result\",\n    false\n  );\n\n  Map.addLayer(\n    buildings_outline,\n    { palette: building_palette, min: 0.6, max: 2 },\n    \"Damaged Buildings\",\n    true\n  );\n\n  Map.addLayer(\n    roads_white_outline,\n    { palette: [\"ffffff\"], min: 0, max: 1 },\n    \"Roads White Outline\",\n    false\n  );\n\n  Map.addLayer(\n    roads_outline,\n    { palette: building_palette, min: 0.6, max: 2 },\n    \"Damaged Roads\",\n    false\n  );\n\n  // Add city boundary layer\n  Map.addLayer(cityBoundaries, {}, 'adminboundaries');\n  \n  // Restore layer visibility state\n  updateLayerVisibility();\n  \n  // Reset results panel\n  updateResultsPanel();\n}\n\n// Update layer visibility state\nfunction updateLayerVisibility() {\n  // Set layer visibility based on checkbox state\n  var buildingsLayer = getLayerByName(\"Damaged Buildings\");\n  if (buildingsLayer) {\n    buildingsLayer.setShown(buildingsCheckbox.getValue());\n  }\n  \n  var whiteOutlineLayer = getLayerByName(\"Roads White Outline\");\n  var roadsLayer = getLayerByName(\"Damaged Roads\");\n  if (whiteOutlineLayer && roadsLayer) {\n    whiteOutlineLayer.setShown(roadsCheckbox.getValue());\n    roadsLayer.setShown(roadsCheckbox.getValue());\n  }\n  \n  var ttestLayer = getLayerByName(\"T-test Result\");\n  if (ttestLayer) {\n    ttestLayer.setShown(ttestCheckbox.getValue());\n  }\n}\n\n// -------------------------------------\n// Create download panel\nvar downloadPanel = ui.Panel({\n  layout: ui.Panel.Layout.flow('vertical'),\n  style: {stretch: 'horizontal', margin: '5px 0'}\n});\n\n// Add download title\ndownloadPanel.add(ui.Label('Download Damage Buildings Data', {\n  fontSize: '16px',\n  fontWeight: 'bold'\n}));\n\n// Label for displaying download link\nvar downloadUrlLabel = ui.Label(' ',{\n  fontSize: '13px'\n});\n\n// Create download button\nvar downloadButton = ui.Button({\n  label: 'Get Download Link',\n  onClick: function() {\n    // Get currently selected city\n    var selectedCity = citySelect.getValue();\n    \n    // Get corresponding AOI based on selected city\n    var cityAOI;\n    if (selectedCity === 'Mariupol') {\n      cityAOI = ukr1;\n    } else if (selectedCity === 'Kharkiv') {\n      cityAOI = ukr7;\n    }\n    \n    // Filter damaged buildings for current city\n    var city_buildings = damaged_building.filterBounds(cityAOI).filter(ee.Filter.gt(\"mean\", 0));\n    \n    // Generate current date-time string as part of filename\n    var filename = selectedCity + '_damaged_buildings_' + ee.Date(SHOCK_DATE).advance(POST_INTERVAL, \"month\").format('YYYY-MM-dd').getInfo();\n    \n    // Get download link\n    var url = city_buildings.getDownloadURL({\n      format: 'GeoJSON',\n      filename: filename\n    });\n    \n    // Update download link label\n    downloadUrlLabel.setUrl(url);\n    downloadUrlLabel.setValue('Download Link');\n    downloadUrlLabel.style().set({\n      fontSize: '13px',\n      color: 'blue',\n      textDecoration: 'underline'\n    });\n  },\n  style: {\n    stretch: 'horizontal',\n    textAlign: 'center',\n    margin: '5px 0'\n  }\n});\n\n// Add download button to download panel\ndownloadPanel.add(downloadButton);\ndownloadPanel.add(downloadUrlLabel);\n\n// -------------------------------------\n// Credit panel\nvar creditsNotes = ui.Panel([\n  ui.Label('Credits:', {fontSize: '12px', margin: '8px 8px 1px 8px', fontWeight: 'bold'}),\n  ui.Panel([\n    ui.Label('â€¢ Data source: ', {fontSize: '12px', margin: '0px 8px 8px 8px'}),\n    ui.Label('Sentinel-1', {fontSize: '12px', margin: '0px 8px 8px 0px'}, 'https://sentiwiki.copernicus.eu/web/s1-mission')\n  ], ui.Panel.Layout.flow('horizontal'), {margin: '0px 0px 0px 0px', padding: '0px 0px 0px 0px'}),\n  ui.Panel([\n    ui.Label('â€¢ Building Footprints: ', {fontSize: '12px', margin: '0px 8px 8px 8px'}),\n    ui.Label('Overture Maps Foundation', {fontSize: '12px', margin: '0px 8px 8px 0px'}, 'https://overturemaps.org/')\n  ], ui.Panel.Layout.flow('horizontal'), {margin: '0px 0px 0px 0px', padding: '0px 0px 0px 0px'}),\n  ui.Panel([\n    ui.Label('â€¢ Road Network: ', {fontSize: '12px', margin: '0px 8px 8px 8px'}),\n    ui.Label('OSM', {fontSize: '12px', margin: '0px 8px 8px 0px'}, 'https://www.openstreetmap.org/')\n  ], ui.Panel.Layout.flow('horizontal'), {margin: '0px 0px 0px 0px', padding: '0px 0px 0px 0px'})\n]);\n\n// Add all panels to left control panel\nleftPanel.add(titlePanel);\nleftPanel.add(lineBreak);\nleftPanel.add(cityPanel);\nleftPanel.add(timePanel);\nleftPanel.add(layerPanel);\nleftPanel.add(assessPanel);\nleftPanel.add(downloadPanel);\nleftPanel.add(creditsNotes);\n\n\n// Hide zoom button in top-left corner of map\nMap.setControlVisibility({zoomControl: false});\n\n// -------------------------------------\n// Comparison slider functionality\n// Create two map instances\nvar leftMap = ui.Map();  // Left map, showing analysis results\nvar rightMap = ui.Map();  // Right map, showing satellite imagery\n\n// Add left control panel to left map\nleftMap.add(leftPanel);\n\n// Set left map layers - copy all layers from original Map to leftMap\nfunction copyLayersToLeftMap() {\n  // First clear existing layers on leftMap\n  while (leftMap.layers().length() &gt; 0) {\n    leftMap.layers().remove(leftMap.layers().get(0));\n  }\n  \n  // Add building change layer\n  leftMap.addLayer(\n    composite_image,\n    { min: 0, max: 4, opacity: 0.8, palette: palette },\n    \"T-test Result\",\n    false  // Not displayed by default\n  );\n  \n  // Add building outline layer\n  leftMap.addLayer(\n    buildings_outline,\n    { palette: building_palette, min: 0.6, max: 2 },\n    \"Damaged Buildings\",\n    true  // Displayed by default\n  );\n  \n  // First add white border layer\n  leftMap.addLayer(\n    roads_white_outline,\n    { palette: [\"ffffff\"], min: 0, max: 1 },\n    \"Roads White Outline\",\n    false  // Not displayed by default\n  );\n  \n  // Then add colored road layer\n  leftMap.addLayer(\n    roads_outline,\n    { palette: building_palette, min: 0.6, max: 2 },\n    \"Damaged Roads\",\n    false  // Not displayed by default\n  );\n  \n  // Add city boundary layer\n  leftMap.addLayer(cityBoundaries, {}, 'adminboundaries');\n  \n  // Restore layer visibility state\n  updateLeftMapLayerVisibility();\n}\n\n// Update left map layer visibility\nfunction updateLeftMapLayerVisibility() {\n  // Set layer visibility based on checkbox state\n  var buildingsLayer = getLeftMapLayerByName(\"Damaged Buildings\");\n  if (buildingsLayer) {\n    buildingsLayer.setShown(buildingsCheckbox.getValue());\n  }\n  \n  var whiteOutlineLayer = getLeftMapLayerByName(\"Roads White Outline\");\n  var roadsLayer = getLeftMapLayerByName(\"Damaged Roads\");\n  if (whiteOutlineLayer && roadsLayer) {\n    whiteOutlineLayer.setShown(roadsCheckbox.getValue());\n    roadsLayer.setShown(roadsCheckbox.getValue());\n  }\n  \n  var ttestLayer = getLeftMapLayerByName(\"T-test Result\");\n  if (ttestLayer) {\n    ttestLayer.setShown(ttestCheckbox.getValue());\n  }\n}\n\n// Get left map specific layer name\nfunction getLeftMapLayerByName(name) {\n  var layers = leftMap.layers().getJsArray();\n  for (var i = 0; i &lt; layers.length; i++) {\n    if (layers[i].getName() === name) {\n      return layers[i];\n    }\n  }\n  return null;\n}\n\n// Set right map layers - show satellite imagery\nfunction setRightMapLayers() {\n  // First clear existing layers on rightMap\n  while (rightMap.layers().length() &gt; 0) {\n    rightMap.layers().remove(rightMap.layers().get(0));\n  }\n  \n  // Set satellite base map\n  rightMap.setOptions('HYBRID');\n  \n  // Add building footprint (white outline)\n  var emptyBuildings = ee.Image().byte();\n  var buildingsOutlineWhite = emptyBuildings.paint({\n    featureCollection: damaged_building,\n    color: 1,\n    width: 1.5\n  });\n  \n  rightMap.addLayer(\n    buildingsOutlineWhite,\n    {palette: ['white'], min: 0, max: 1, opacity: 0.7},\n    'Buildings Footprint',\n    true\n  );\n}\n\n// Initialize left and right maps\ncopyLayersToLeftMap();\nsetRightMapLayers();\n\n// Set initial center position\nleftMap.centerObject(mariupolCenter, 14);\nrightMap.centerObject(mariupolCenter, 14);\n\n// Create map linker to synchronize two maps\nvar linker = ui.Map.Linker([leftMap, rightMap]);\n\n// Modify city selection dropdown onChange event, update both maps\ncitySelect.onChange(function(value) {\n  // Get current city center\n  var cityCenter;\n  var zoomLevel;\n  \n  if (value === 'Kharkiv') {\n    cityCenter = kharkivCenter;\n    zoomLevel = 13;\n  } else { // Mariupol\n    cityCenter = mariupolCenter;\n    zoomLevel = 14;\n  }\n  \n  // Update center position of both maps\n  leftMap.centerObject(cityCenter, zoomLevel);\n  rightMap.centerObject(cityCenter, zoomLevel);\n  \n  // Update right map\n  setRightMapLayers();\n});\n\n// Modify layer checkbox onChange event to update left map\nbuildingsCheckbox.onChange(function(isChecked) {\n  var layer = getLeftMapLayerByName(\"Damaged Buildings\");\n  if (layer) {\n    layer.setShown(isChecked);\n  }\n});\n\nroadsCheckbox.onChange(function(isChecked) {\n  var whiteOutline = getLeftMapLayerByName(\"Roads White Outline\");\n  var roads = getLeftMapLayerByName(\"Damaged Roads\");\n  \n  if (whiteOutline) {\n    whiteOutline.setShown(isChecked);\n  }\n  \n  if (roads) {\n    roads.setShown(isChecked);\n  }\n});\n\nttestCheckbox.onChange(function(isChecked) {\n  var layer = getLeftMapLayerByName(\"T-test Result\");\n  if (layer) {\n    layer.setShown(isChecked);\n  }\n});\n\n// Create split panel\nvar splitPanel = ui.SplitPanel({\n  firstPanel: leftMap,\n  secondPanel: rightMap,\n  orientation: 'horizontal',\n  wipe: true,\n  style: {stretch: 'both'}\n});\n\n// Add split panel to UI root widget\nui.root.widgets().reset([splitPanel]);\n\n// ensure that each initialization starts from 2022-3-24\nreanalyzeWithNewInterval();\n\n\n\n\nBallinger, O. (2024) 9 Blast Damage Assessment (WWW) London: CASA (https://github.com/oballinger/CASA0025/; 12 Mar 2024).\nDietrich, O., Peters, T., Sainte Fare Garnot, V. and others (2025) An open-source tool for mapping war destruction at scale in Ukraine using Sentinel-1 time series, Communications Earth & Environment, 6, 215. Available at: https://doi.org/10.1038/s43247-025-02183-7 [Accessed 27 April 2025].\nUSGS, 2018. NDVI: The Foundation of Remote Sensing Phenology. [online] Available at: https://www.usgs.gov/special-topics/remote-sensing-phenology/science/ndvi-foundation-remote-sensing-phenology [Accessed 27 April 2025].\nWang, X. and Li, P. (2020) Extraction of urban building damage using spectral, height and corner information from VHR satellite images and airborne LiDAR data, ISPRS Journal of Photogrammetry and Remote Sensing, 159."
  },
  {
    "objectID": "index.html#project-summary",
    "href": "index.html#project-summary",
    "title": "Assessing Urban War Damage in Kharkiv and Mariupol, Ukraine Using Sentinel-1 Imagery",
    "section": "",
    "text": "What is the problem youâ€™re trying to address using this application?\nThis application addresses the need for transparent, cost-effective tools to assess infrastructure damage in urban areas affected by the Russiaâ€“Ukraine war. It focuses on Kharkiv and Mariupol, the two most affected cities, and estimates building and road damage using a lightweight, unsupervised pixel-wise t-test on freely available Sentinel-1 imagery. Although the war is ongoing, our analysis focuses on the year before and after February 24, 2022, when the full-scale invasion began. Unlike deep learning approaches requiring expensive optical imagery, this method supports repeatable, scalable, and interpretable analysis. The results can assist post-war reconstruction planning, guide humanitarian aid, and inform public understanding of urban destruction patterns in these cities.\n\n\n\nWho are you building this application for? How does it address a need this community has?\n\nGovernment and planning departments: Initial analyze damage patterns and damage to specific facilities (e.g.Â housing, hospitals) to prioritise reconstruction and allocate resources effectively.\nHumanitarian organisations: Quickly identify severely damaged areas and assess damage to critical infrastructure and residential areas to provide guidance for emergency shelter, public health and logistics planning.\nRemote sensing and disaster assessment professionals: Use damage data to validate models, track changes, and compare methods or datasets in disaster impact studies.\nPublic and media: Explore clear, visual maps of war damage, thereby raising public awareness, and can provide data to support news reporting.\n\n\n\n\nWhat data are you using?\n\nSentinel-1 Imagery\nThis application uses Sentinel-1 Imagery provided by Google Earth Engine. To simplify processing and prioritize sensitivity to structural damage, only VH-polarized imagery was used. The data spans February 24, 2020 to February 24, 2023, covering placebo, pre-war, and war phases. From February 2022, imagery was compared monthly to capture temporal changes in damage.\nBuilding Footprints\nBuilding footprint data is sourced from the Overture Maps Foundation, which combines several open datasets, primarily from OpenStreetMap, Microsoft, and Google Open Buildings. Buildings smaller than 50 mÂ² were excluded due to potential building false positives and the resolution of Sentinel-1.\nRoad Networks\nThe road network data was retrieved from OpenStreetMap using the OSMnx package in Python, extracting roads classified as trunk, primary, secondary, and tertiary, and simplifying bidirectional edges.\n\n\n\n\nHow are you using this data to address the problem?\nWe used Sentinel-1 SAR imagery to perform a pixel statistical test (t-test) for pre- and post-war changes, identifying potential damage on the map. Overlaying the building footprints and road network data with t-test results to locate and classify damage, and calculate the percentage of damaged buildings and roads, and different subtypes of damaged buildings at 95% confidence intervals. Through monthly monitoring of post-war damages for 12 months after 2022-2-24, the evolution of the war impact will be tracked, and user can select different times to view changes in damages. These features will support urban damage assessment and post-war reconstruction planning.\n\n\n\nHow does your applicationâ€™s interface work to address the needs of your end user?\nThe application provides clear, visual maps of war damage, enabling the public and researchers in remote sensing and disaster assessment to track the evolution of destruction and the recovery process over time. Layer comparison tools help Ukrainian government and humanitarian organizations visually identify specific areas are affected, supporting resource planning and decision-making for wartime relief and post-disaster reconstruction. The application also calculates the proportion of damaged buildings and roads, and visualizes the distribution of damage across different building types, offering reference statistics for researchers. All users can export damaged building GeoJSON data to conduct urban assessments and make data-driven decisions."
  },
  {
    "objectID": "index.html#how-it-works",
    "href": "index.html#how-it-works",
    "title": "Assessing Urban War Damage in Kharkiv and Mariupol, Ukraine Using Sentinel-1 Imagery",
    "section": "",
    "text": "Full code can be found here.\n\n\nWe imported the vector data, including building footprints with building type information and 7.5-meter-wide rectangular road layers, and merged the data from two cities.\n// ----------------------- Import Data -----------------------  \n// Building footprint\nvar buildings_ukr1 = ee.FeatureCollection(\"projects/ee-yiyaocui/assets/ukr1\");\nvar buildings_ukr7 = ee.FeatureCollection(\"projects/ee-yiyaocui/assets/ukr7\");\nvar buildings = buildings_ukr1.merge(buildings_ukr7);\n\n// Roads\nvar roads_ukr1 = ee.FeatureCollection(\"projects/ee-yiyaocui/assets/osm_ukr1_buffer_50_75_8\")\n  .filterBounds(aoi);\nvar roads_ukr7 = ee.FeatureCollection(\"projects/ee-yiyaocui/assets/osm_ukr7_buffer_50_75_14\")\n  .filterBounds(aoi);\nvar roads = roads_ukr1.merge(roads_ukr7);\nThen, we set up our area of interest (AOI), time range, and mapâ€™s centroids. For time range:\n\nSHOCK_DATE: 2022-02-24, when Russia launched a full-scale military invasion of Ukraine.\nPRE_INTERVAL: 12-month pre-event period (baseline).\nPOST_INTERVAL: 12-month post-event period (all assessment windows).\n\nWe defined a updateDateRanges() function to flexibly select an assessment window for the interactive tool.\n// ----------------------- Set-up  -----------------------\n//AOI\nvar cityBoundaries = ee.FeatureCollection(\"projects/ee-yiyaocui/assets/unosat_aois\")\n  .style({\n    color: 'red', \n    fillColor: '00000000',\n    width: 1 \n  });\nvar aoi = cityBoundaries.geometry();\nvar ukr1 = ee.Geometry.Rectangle([37.46, 47.06, 37.72, 47.16]);\nvar ukr7 = ee.Geometry.Rectangle([36.09, 49.87, 36.46, 50.11]);  \nvar aoi = ee.FeatureCollection([\n  ee.Feature(ukr1),\n  ee.Feature(ukr7)\n]).merge(ee.FeatureCollection([])).geometry();\n\n//Time \nvar SHOCK_DATE = \"2022-02-24\";\nvar PRE_INTERVAL = 12;  // month before the event\nvar POST_INTERVAL = 12; // month after the event\n// Calculate precise data filtering range, recalculate when POST_INTERVAL changes\nfunction updateDateRanges() {\n  var startDate = ee.Date(SHOCK_DATE).advance(-PRE_INTERVAL, \"month\").format(\"YYYY-MM-dd\");\n  var endDate = ee.Date(SHOCK_DATE).advance(POST_INTERVAL, \"month\").format(\"YYYY-MM-dd\");\n  return {startDate: startDate, endDate: endDate};\n}\n// Initialize date range\nvar dateRanges = updateDateRanges();\nvar startDate = dateRanges.startDate;\nvar endDate = dateRanges.endDate; \n\n// Centroid\nMap.centerObject(cityBoundaries, 8);\n\n// Centroid of mariupol \nvar mariupolCenter = ee.Geometry.Point([37.59269, 47.09966]);\nMap.centerObject(mariupolCenter, 14);\n\n\n\nBased on the tutorial code from CASA0025 Week 9 (Ballinger, O., 2024), we used the following equation to compute the t-value for each pixel, comparing radar backscatter values before and after the war:\n\\[ \\Large t = {\\frac{\\overline{x_1}-\\overline{x_2}} {\\sqrt{\\frac{s^2_1}{n_1} + \\frac{s^2_2}{n_2}}}} \\]\nWhere:\n\n\\(\\overline{x_1}\\)ï¼šmean of the pre-war imagery // code variables: pre-mean\n\\(\\overline{x_2}\\)ï¼šmean of the post-war imagery // code variables: post_mean\n\\(s_1^2, s_2^2\\)ï¼švariance of the pre- and post-war data // code variables: pre_sd, post_sd; \\(s^2\\) is implied as \\(sd^2\\)\n\\(n_1, n_2\\)ï¼šnumber of images before and after the war // code variables: pre_n, post_n\n\nThis approach helps quantify whether observed changes are statistically significant and is particularly useful when ground-truth data is limited. Finally, a t-value greater than 2.5 indicates a significant change at the 99% confidence level.\n// ----------------------- TTest function  -----------------------\n// t-test function (building analysis)\nfunction ttest(s1, shock, pre_interval, post_interval) {\n  // Convert event date to ee.Date object\n  var shock = ee.Date(shock);\n  // Filter pre-event images: from (shock - pre_interval months) to shock\n  var pre = s1.filterDate(\n    shock.advance(ee.Number(pre_interval).multiply(-1), \"month\"),\n    shock\n  );\n  // Filter post-event images: from shock to (shock + post_interval months)\n  var post = s1.filterDate(shock, shock.advance(post_interval, \"month\"));\n  // Calculate pre-event mean, standard deviation, and image count\n  var pre_mean = pre.mean();\n  var pre_sd = pre.reduce(ee.Reducer.stdDev());\n  var pre_n = ee.Number(pre.filterBounds(aoi).size());\n  // Calculate post-event mean, standard deviation, and image count\n  var post_mean = post.mean();\n  var post_sd = post.reduce(ee.Reducer.stdDev());\n  var post_n = ee.Number(post.filterBounds(aoi).size());\n  // Print pre and post event image counts for debugging\n  print('Pre-event images count: ', pre_n);\n  print('Post-event images count: ', post_n);\n  // Calculate pooled standard deviation\n  var pooled_sd = pre_sd\n    .multiply(pre_sd)\n    .multiply(pre_n.subtract(1))\n    .add(post_sd.multiply(post_sd).multiply(post_n.subtract(1)))\n    .divide(pre_n.add(post_n).subtract(2))\n    .sqrt();\n  // Calculate denominator part of t-test formula\n  var denom = pooled_sd.multiply(\n    ee.Number(1).divide(pre_n).add(ee.Number(1).divide(post_n)).sqrt()\n  );\n  // Calculate degrees of freedom (number of observations minus 2)\n  var df = pre_n.add(post_n).subtract(2);\n  print(\"Number of Images: \", df);\n  // Calculate t-value: absolute difference of means divided by denominator, minus 2\n  var change = post_mean\n    .abs()\n    .subtract(pre_mean.abs())\n    .divide(denom)\n    .abs()\n    .subtract(2.5);\n   \n  // Return t-value for each pixel\n  return change;\n}\nWe filter Sentinel-1 radar images by selecting the VH polarization band and the most common orbit number, then separately process ASCENDING and DESCENDING orbits to reduce directional noise. Also, we use NDVI to reduce vegetation disturbance (NDVI &gt; 0.2: vegetation)(Wang, X.&Li, P., 2020; USGS,2018).\n// ----------------------- Satellite Image -----------------------\n// Select Sentinel 1 images collection for analysis\nfunction filter_s1(path) {\n  var s1 = ee\n    .ImageCollection(\"COPERNICUS/S1_GRD\")\n    .filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VH\"))\n    .filter(ee.Filter.eq(\"instrumentMode\", \"IW\"))\n    .filter(ee.Filter.eq(\"orbitProperties_pass\", path))\n    .filterBounds(aoi)\n    .filterDate(startDate, endDate)\n    .select(\"VH\");\n\n  var orbit = s1\n    .aggregate_array(\"relativeOrbitNumber_start\")\n    .reduce(ee.Reducer.mode());\n\n  s1 = s1.filter(ee.Filter.eq(\"relativeOrbitNumber_start\", orbit));\n\n  // Return change in t-value\n  var change = ttest(s1, SHOCK_DATE, PRE_INTERVAL, POST_INTERVAL)\n  return change;\n}\n\n// Select sentinel image for calculation\nvar ascending_image = filter_s1(\"ASCENDING\");\nvar descending_image = filter_s1(\"DESCENDING\");\nvar asc_des = ee.ImageCollection([ascending_image, descending_image])\n  .median() // use median to reduce impacts of outliers\n  .clip(aoi);\n\n// Add NDVI Mask\nvar s2 = ee.ImageCollection('COPERNICUS/S2_SR')\n  .filterDate(startDate, SHOCK_DATE)\n  .filterBounds(aoi)\n  .select(['B4','B8'])\n  .median(); \nvar ndvi = s2.normalizedDifference(['B8','B4']).rename('NDVI');\nvar ndvi_mask = ndvi.gt(0.2);\n\n// Generate Composite Image\nvar composite_image = asc_des.where(ndvi_mask, 0);\nThen we overlay the t-test output with building and road layers to estimate the number of damaged buildings and roads in each city. As roads are sensitive to neighboring pixels, we defined damaged roads with at least 50% significant pixels.\n// ----------------------- Analysis -----------------------\n\n// Select significant pixel where t-value is positive (99% confidence interval)\nvar threshold = composite_image.updateMask(composite_image.gt(0));\n\n// Detect damaged buildings and roads\nvar damaged_building = threshold.reduceRegions({\n  collection: buildings,\n  reducer: ee.Reducer.mean(),\n  scale: 10\n});\n\nvar damaged_roads = threshold.reduceRegions({\n  collection: roads,\n  reducer: ee.Reducer.mean(),\n  scale: 10\n});\n\n// ----------------------- Calculation -----------------------\n// Calculate the number of damaged buildings/roads by cities \n//Buildings\nvar mariupol_buildings = damaged_building.filterBounds(ukr1).filter(ee.Filter.gt(\"mean\", 0));\nvar kharkiv_buildings = damaged_building.filterBounds(ukr7).filter(ee.Filter.gt(\"mean\", 0));\nvar total_buildings = mariupol_buildings.merge(kharkiv_buildings);\n\n//Roads\nvar mariupol_roads = damaged_roads.filterBounds(ukr1).filter(ee.Filter.gt(\"mean\", 0.5));\nvar kharkiv_roads = damaged_roads.filterBounds(ukr7).filter(ee.Filter.gt(\"mean\", 0.5));\nvar total_roads = mariupol_roads.merge(kharkiv_roads);\n\n// ----------------------- Visualization -----------------------\n// Define color palettes for damaged buildings and roads\nvar palette = [\"FFFFFF\", \"3b528b\", \"21918c\", \"5ec962\", \"fde725\"];\nvar building_palette = [\"FFF3D6\", \"FFDD9E\", \"FFBE66\", \"FF9A3D\", \"FF7519\", \"FF5100\", \"FD3000\"]; \n\n// ----------------------- Layers -----------------------\n//ttest\nMap.addLayer(\n  composite_image,\n  { min: 0, max: 4, opacity: 0.8, palette: palette },\n  \"Buildings Change\",\n  false  // Not displayed by default\n);\n\n// Building Footprint Outline\nvar empty_buildings = ee.Image().byte();\nvar buildings_outline = empty_buildings.paint({\n  featureCollection: damaged_building,\n  color: \"mean\",\n  width: 1.5\n});\n\n// Draw road outline - add white border\nvar empty_roads = ee.Image().byte();\n\n// First create a wider white border\nvar roads_white_outline = empty_roads.paint({\n  featureCollection: damaged_roads,\n  color: 1,  // White\n  width: 9   // Wider than normal width to form a border\n});\n\n// Then create normal width colored roads\nvar roads_outline = empty_roads.paint({\n  featureCollection: damaged_roads,\n  color: \"mean\",\n  width: 5\n});\n\n//  Mapping for checking but displayed by default for user interface design \n// Add building outline layer\nMap.addLayer(\n  buildings_outline,\n  { palette: building_palette, min: 0.6, max: 2 },\n  \"Damaged Buildings\",\n  true  // Displayed by default\n);\n\n// First add white border layer\nMap.addLayer(\n  roads_white_outline,\n  { palette: [\"ffffff\"], min: 0, max: 1 },\n  \"Roads White Outline\",\n  false  // Not displayed by default\n);\n// Then add colored road layer\nMap.addLayer(\n  roads_outline,\n  { palette: building_palette, min: 0.6, max: 2 },\n  \"Damaged Roads\",\n  false  // Not displayed by default\n);\n\n// Add city boundary layer\nMap.addLayer(cityBoundaries, {}, 'adminboundaries');\n\n\n\n\n\n\nColor Icon\nColor Name\nDamage Level\n\n\n\n\nðŸ”µ\nBlue\nNo damage\n\n\nðŸŸ¢\nGreen\nLow damage\n\n\nðŸŸ¡ðŸŸ \nYellow / Orange\nMedium damage\n\n\nðŸ”´\nRed\nHigh levels of damage\n\n\n\n\n\n \nThe placebo test showed cumulative natural disturbances, stronger and seasonal in Kharkiv, and mainly industrial in Mariupol, with visible improvement after vegetation removal.\n\n\n\nIn the t-test evaluations, our method effectively identified large-scale damage to buildings and roads, supported by the prior separation of built-up areas from open green spaces.\n \nIn Area A, structural damage was accurately detected without interference from surrounding vegetation; in Area B, major building footprint damage was captured with slight spatial overflow; and in Area C, gaps between adjacent row houses were clearly distinguished. On roads, the model correctly detected heavily damaged sections alongside buildings in Area D, but misclassified a functioning road in Area E as moderately damaged.\n\n\n\nIn addition, we compared our outcome to UNOSAT Ground truth datasets to validate the modelâ€™s performance to detect damaged buildings by spatially interactive matching. (UNOSAT, cited in Dietrich et al., 2025)\n##### Results\nTable 1: Mariupol with 99% confidence interval\n\n\n\nMetric\nValue\n\n\n\n\nTP (True Positive)\n3362\n\n\nFP (False Positive)\n5800\n\n\nFN (False Negative)\n1831\n\n\nTN (True Negative)\n8695\n\n\nPrecision\n0.3670\n\n\nRecall\n0.6474\n\n\nSpecificity\n0.5999\n\n\nAccuracy\n0.6124\n\n\nF1 Score\n0.4684\n\n\n\n\nTable 2: Mariupol with 95% confidence interval\n\n\n\nMetric\nValue\n\n\n\n\nTP (True Positive)\n3908\n\n\nFP (False Positive)\n7932\n\n\nFN (False Negative)\n1285\n\n\nTN (True Negative)\n6563\n\n\nPrecision\n0.3301\n\n\nRecall\n0.7526\n\n\nSpecificity\n0.4528\n\n\nAccuracy\n0.5318\n\n\nF1 Score\n0.4589\n\n\n\n\nTable 3: Kharkiv with 99% confidence interval\n\n\n\nMetric\nValue\n\n\n\n\nTP (True Positive)\n689\n\n\nFP (False Positive)\n57286\n\n\nFN (False Negative)\n182\n\n\nTN (True Negative)\n58532\n\n\nPrecision\n0.0119\n\n\nRecall\n0.7910\n\n\nSpecificity\n0.5054\n\n\nAccuracy\n0.5075\n\n\nF1 Score\n0.0234\n\n\n\n\nTable 4: Kharkiv with 95% confidence interval\n\n\n\nMetric\nValue\n\n\n\n\nTP (True Positive)\n751\n\n\nFP (False Positive)\n72650\n\n\nFN (False Negative)\n120\n\n\nTN (True Negative)\n43168\n\n\nPrecision\n0.0102\n\n\nRecall\n0.8622\n\n\nSpecificity\n0.3727\n\n\nAccuracy\n0.3764\n\n\nF1 Score\n0.0202\n\n\n\nConclusively, using a 99% confidence interval improved predictive performance. In Mariupol, the F1 score reached 0.4684, demonstrating reasonable effectiveness, while Kharkivâ€™s F1 score remained low at 0.0234.\nPerformance limitations were likely linked to natural disturbances, pixel spill-over effects caused by the resolution constraints of 10-metre imagery, temporal mismatches with manual labels due to the cumulative nature of warfare destruction and unclear damage definitions, and missing road footprint and subtype data.\nWhile the method remains valuable for preliminary screening by international organisations, future improvements should prioritize refined preprocessing, clearer damage definitions, multi-temporal validation, and the potential integration of supervised learning techniques to enhance overall accuracy.\n\n\n\n\nThe following part is the code for UI design.\n// ------------------------------------- USER INTERFACE -------------------------------------\n\n// Create left control panel\nvar leftPanel = ui.Panel({\n  style: {\n    position: 'top-left',\n    minWidth: '290px',\n    width: '22%',\n    maxWidth: '500px',\n    maxHeight: '88%',\n    height: 'auto'\n  },\n  layout: ui.Panel.Layout.flow('vertical', true)\n});\n\n// Title panel\nvar titlePanel = ui.Panel([\n  ui.Label('Ukraine Buildings and Roads Damage Assessment', {\n    fontWeight: 'bold',\n    fontSize: '20px'\n  }),\n  ui.Label('Assessing Urban War Damage in Kharkiv and Mariupol, Ukraine Using Sentinel-1 Imagery')\n]);\n\n// Add separator line\nvar lineBreak = ui.Panel({\n  style: {\n    stretch: 'horizontal',\n    height: '1px',\n    backgroundColor: '000',\n    margin: '8px 0px 8px 0px'\n  }\n});\n\n// Set Mariupol and Kharkiv city center coordinates\nvar mariupolCenter = ee.Geometry.Point([37.59269, 47.09966]);\nvar kharkivCenter = ee.Geometry.Point([36.232845, 49.988358]);\n\n// Create city selection dropdown\nvar citySelect = ui.Select({\n  items: ['Mariupol','Kharkiv'],\n  value: 'Mariupol',\n  onChange: function(value) {\n    if (value === 'Kharkiv') {\n      Map.centerObject(kharkivCenter, 13);\n    } else if (value === 'Mariupol') {\n      Map.centerObject(mariupolCenter, 14);\n    }\n  },\n  style: {stretch: 'horizontal', textAlign: 'center'}\n});\n\n\nvar cityPanel = ui.Panel([\n  ui.Label('Select City', {\n    textAlign: 'center',\n    fontSize: '16px',\n    fontWeight: 'bold'\n  }),\n  citySelect\n])\n\n\n// create a time selection panel\nvar timePanel = ui.Panel({\n  layout: ui.Panel.Layout.flow('vertical'),\n  style: {padding: '5px 0'}\n});\n\ntimePanel.add(ui.Label('Select Time Period', {\n  fontSize: '16px',\n  fontWeight: 'bold',\n  textAlign: 'center'\n}));\n\n// create a start date information (fixed value)\nvar formattedStartDate = ee.Date(SHOCK_DATE).format('YYYY-MM-dd').getInfo();\ntimePanel.add(ui.Label('Start Date:' + formattedStartDate +' (Fixed)', {\n  textAlign: 'left'\n}));\n\n// create a date picker to select a time interval\nvar endDateLabel = ui.Label('End Date:', {\n  textAlign: 'left'\n});\ntimePanel.add(endDateLabel);\n\n// set up the month interval options\nvar intervalOptions = [\n  {label: '1 months (2022-03-24)', value: 1},\n  {label: '2 months (2022-04-24)', value: 2},\n  {label: '3 months (2022-05-24)', value: 3},\n  {label: '4 months (2022-06-24)', value: 4},\n  {label: '5 months (2022-07-24)', value: 5},\n  {label: '6 months (2022-08-24)', value: 6},\n  {label: '7 months (2022-09-24)', value: 7},\n  {label: '8 months (2022-10-24)', value: 8},\n  {label: '9 months (2022-11-24)', value: 9},\n  {label: '10 months (2022-12-24)', value: 10},\n  {label: '11 months (2023-01-24)', value: 11},\n  {label: '12 months (2023-02-24)', value: 12}\n];\n\n// create a time interval selection drop-down box\n// default set the POST_INTERVAL to 1, to compare with the first month\nvar POST_INTERVAL = 1;\nvar intervalSelect = ui.Select({\n  items: intervalOptions,\n  value: POST_INTERVAL,\n  onChange: function(value) {\n    POST_INTERVAL = Number(value);\n    reanalyzeWithNewInterval();\n    // update the left map\n    copyLayersToLeftMap();\n    // update the right map\n    setRightMapLayers();\n  },\n  style: {stretch: 'horizontal'}\n});\n\ntimePanel.add(intervalSelect);\n\ntimePanel.add(ui.Label('Select different time periods to view the evolution of war impacts on cities', {\n  fontSize: '11px'\n}));\n\n// -------------------------------------\n// Layer control panel\nvar layerPanel = ui.Panel({\n  widgets: [\n    ui.Label('Select Layers', {\n      fontSize: '16px',\n      fontWeight: 'bold'\n    })\n  ],\n  layout: ui.Panel.Layout.flow('vertical', false),  // Set to false to disable scrollbar\n  style: {padding: '0px', margin: '0px', maxHeight: 'none'}  // Ensure no height limit\n});\n\n// Get layer by specific name\nfunction getLayerByName(name) {\n  var layers = Map.layers().getJsArray();\n  for (var i = 0; i &lt; layers.length; i++) {\n    if (layers[i].getName() === name) {\n      return layers[i];\n    }\n  }\n  return null;\n}\n\n// Create layer checkboxes\nvar buildingsCheckbox = ui.Checkbox({\n  label: 'Buildings',\n  value: true,  // Selected by default\n  onChange: function(isChecked) {\n    // Use name to find layer instead of index\n    var layer = getLayerByName(\"Damaged Buildings\");\n    if (layer) {\n      layer.setShown(isChecked);\n    }\n  }\n});\n\nvar roadsCheckbox = ui.Checkbox({\n  label: 'Roads',\n  value: false,  // Not selected by default\n  onChange: function(isChecked) {\n    // Control both road layers simultaneously\n    var whiteOutline = getLayerByName(\"Roads White Outline\");\n    var roads = getLayerByName(\"Damaged Roads\");\n    \n    if (whiteOutline) {\n      whiteOutline.setShown(isChecked);\n    }\n    \n    if (roads) {\n      roads.setShown(isChecked);\n    }\n  }\n});\n\nvar ttestCheckbox = ui.Checkbox({\n  label: 'T-test Result',\n  value: false,  // Not selected by default\n  onChange: function(isChecked) {\n    var layer = getLayerByName(\"T-test Result\");\n    if (layer) {\n      layer.setShown(isChecked);\n    }\n  }\n});\n\n// Create a horizontal layout panel to contain checkboxes\nvar checkboxPanel = ui.Panel({\n  widgets: [buildingsCheckbox, roadsCheckbox, ttestCheckbox],\n  layout: ui.Panel.Layout.flow('horizontal'),\n  style: {stretch: 'horizontal', margin: '4px 0px'}\n});\n\n// Add checkbox horizontal panel to layer control panel\nlayerPanel.add(checkboxPanel);\n\n// Create an empty row as separator\nlayerPanel.add(ui.Label('', {margin: '8px 0px'}));\n\n// Create legend function\nfunction createColorBarPanel() {\n  // Define color array\n  var colors = [\"FFF3D6\", \"FFDD9E\", \"FFBE66\", \"FF9A3D\", \"FF7519\", \"FF5100\", \"FD3000\"];\n  // Create color bar parameters\n  function makeColorBarParams(palette) {\n    return {\n      bbox: [0, 0, 1, 0.1],\n      dimensions: \"100x10\",\n      format: \"png\",\n      min: 0,\n      max: 1,\n      palette: palette,\n    };\n  }\n  \n  // Create legend title\n  var colorBarTitle = ui.Label({\n    value: \"Damage Probability\",\n    style: { fontWeight: \"bold\", textAlign: \"center\", stretch: \"horizontal\"},\n  });\n  \n  // Create color bar\n  var colorBar = ui.Thumbnail({\n    image: ee.Image.pixelLonLat().select(0),\n    params: makeColorBarParams(colors),\n    style: { stretch: \"horizontal\", margin: \"0px 8px\", maxHeight: \"24px\" },\n  });\n  \n  // Create legend labels\n  var colorBarLabels = ui.Panel({\n    widgets: [\n      ui.Label('Low', { margin: \"4px 8px\" }),\n      ui.Label(\" \", {\n        margin: \"4px 8px\",\n        textAlign: \"center\",\n        stretch: \"horizontal\",\n      }),\n      ui.Label('High', { margin: \"4px 8px\" }),\n    ],\n    layout: ui.Panel.Layout.flow(\"horizontal\"),\n  });\n  \n  // Combine all elements\n  var colorBarPanel = ui.Panel({\n    widgets: [colorBarTitle, colorBar, colorBarLabels],\n    style: {stretch: 'horizontal', margin: \"0px 0px 8px 0px\"}\n  });\n  \n  return colorBarPanel;\n}\n\n// Add color legend to layer panel\nlayerPanel.add(createColorBarPanel());\n\n// -------------------------------------\n// Create assessment panel\nvar assessPanel = ui.Panel({\n  layout: ui.Panel.Layout.flow('vertical'),\n  style: {padding: '5px 0', margin: '5px 0'}\n});\n\n// Add title\nassessPanel.add(ui.Label('Calculate Damaged Buildings and Roads', {\n  fontSize: '16px',\n  fontWeight: 'bold'\n}));\n\n// Create results display area\nvar resultsPanel = ui.Panel({\n  layout: ui.Panel.Layout.flow('vertical'),\n  style: {\n    margin: '8px 0px',\n    padding: '8px',\n    border: '1px solid #cccccc',\n    fontSize: '13px'\n  }\n});\nresultsPanel.add(ui.Label('Select a city and click Calculate button to view damage assessment.'));\n\n// Create button panel (horizontal layout)\nvar buttonPanel = ui.Panel({\n  layout: ui.Panel.Layout.flow('horizontal'),\n  style: {stretch: 'horizontal', margin: '5px 0'}\n});\n\n// Create calculate button\nvar calculateButton = ui.Button({\n  label: 'Calculate',\n  onClick: function() {\n    calculateDamage();\n  },\n  style: {\n    stretch: 'horizontal',\n    textAlign: 'center',\n    margin: '5px 2px 5px 0'\n  }\n});\n\n// Create reset button\nvar resetButton = ui.Button({\n  label: 'Reset',\n  onClick: function() {\n    updateResultsPanel();\n  },\n  style: {\n    stretch: 'horizontal',\n    textAlign: 'center',\n    margin: '5px 0 5px 2px'\n  }\n});\n\n// Add buttons to button panel\nbuttonPanel.add(calculateButton);\nbuttonPanel.add(resetButton);\n\n// Add button panel and results panel\nassessPanel.add(buttonPanel);\nassessPanel.add(resultsPanel);\n\n// Results displayed in assessment panel\nfunction updateResultsPanel() {\n  try {\n    // Convert EE object to JavaScript string (for UI display)\n    var formattedEndDate = ee.Date(SHOCK_DATE).advance(POST_INTERVAL, \"month\").format('YYYY-MM-dd').getInfo();\n    \n    // Clear results panel\n    resultsPanel.clear();\n    resultsPanel.add(ui.Label('Select a city and click Calculate button to view damage assessment.'));\n  } catch (e) {\n    print('Error updating results panel:', e);}\n}\n\n// Calculate damage\nfunction calculateDamage() {\n  // Get currently selected city\n  var selectedCity = citySelect.getValue();\n  \n  // Clear results panel and show calculating status\n  resultsPanel.clear();\n  resultsPanel.add(ui.Label('Calculating...', {\n    color: '#0034f5'\n  }));\n  \n  // Force UI to render first, then execute calculation using ee.Number's evaluate method\n  ee.Number(1).evaluate(function() {\n    // Convert EE object to JavaScript string (for UI display)\n    var formattedEndDate;\n    try {\n      formattedEndDate = ee.Date(SHOCK_DATE).advance(POST_INTERVAL, \"month\").format('YYYY-MM-dd').getInfo();\n    } catch (e) {\n      formattedEndDate = \"Error: Could not format date\";\n      print(\"Error formatting end date:\", e);\n    }\n    \n    // Get corresponding AOI based on selected city\n    var cityAOI;\n    if (selectedCity === 'Mariupol') {\n      cityAOI = ukr1;\n    } else if (selectedCity === 'Kharkiv') {\n      cityAOI = ukr7;\n    }\n    \n    try {\n      // Filter buildings and roads for current city\n      var city_buildings = damaged_building.filterBounds(cityAOI).filter(ee.Filter.gt(\"mean\", 0));\n      var city_roads = damaged_roads.filterBounds(cityAOI).filter(ee.Filter.gt(\"mean\", 0));\n      \n      // Calculate totals and proportions\n      // Get total building count for this city (by querying original building data)\n      var total_city_buildings = buildings.filterBounds(cityAOI);\n      var total_city_roads = roads.filterBounds(cityAOI);\n      \n      // get data on damaged buildings and road\n      var damaged_buildings_count = city_buildings.size().getInfo();\n      var total_buildings_count = total_city_buildings.size().getInfo();\n      var damaged_roads_count = city_roads.size().getInfo();\n      var total_roads_count = total_city_roads.size().getInfo();\n      \n      // calculate the percentage of damaged buildings by subtype\n      var buildings_percentage = (damaged_buildings_count / total_buildings_count * 100).toFixed(2);\n      var roads_percentage = (damaged_roads_count / total_roads_count * 100).toFixed(2);\n      var countsDict = ee.Dictionary(city_buildings.aggregate_histogram('subtype'));\n      var subtypeTable = ee.FeatureCollection(\n        countsDict.keys().map(function(k){\n          k = ee.String(k);\n          var n = ee.Number(countsDict.get(k));\n          return ee.Feature(null, {\n            label : k.cat(' (').cat(n.format()).cat(')'),\n            count : n\n          });\n        }));\n      \n      // draw a piechart for damaged building subtype\n      var damagePie = ui.Chart.feature.byFeature(subtypeTable, 'label', ['count']).setChartType('PieChart')\n      .setOptions({\n        pieHole: 0.4,\n        pieSliceText: 'lable',\n        legend: {position: 'bottom',\n        alignment:  'center',\n        textStyle:  {fontSize: 14},\n        maxLines:3},\n        colors:['#0969a2','#ffc700','#ff4e40','#03436a','#ffe073','#ff1300','#245a7a','#ffd540',\n        '#d1b9c2','ff7d73','#64a8d1','bf3a30']\n      });\n      \n      // clear and display results\n      resultsPanel.clear();\n      resultsPanel.add(ui.Label('City:  ',{fontWeight: 'bold'}));\n      resultsPanel.add(ui.Label(selectedCity));\n      resultsPanel.add(ui.Label('Time Period:',{fontWeight: 'bold'}));\n      resultsPanel.add(ui.Label('2022-02-24 to ' + formattedEndDate));\n      resultsPanel.add(ui.Label('Damaged Buildings: ',{fontWeight: 'bold'}));\n      resultsPanel.add(ui.Label(damaged_buildings_count + ' out of ' + total_buildings_count + ' (' + buildings_percentage + '%)'));\n      resultsPanel.add(ui.Label('Damaged Roads: ',{fontWeight: 'bold'}));\n      resultsPanel.add(ui.Label(damaged_roads_count + ' out of ' + total_roads_count + ' (' + roads_percentage + '%)'));\n      resultsPanel.add(ui.Label('Building damage statistics (by building type):',{fontWeight: 'bold'}));\n      resultsPanel.add(damagePie);\n      \n    } catch (e) {\n      // display error messages when errors occur\n      resultsPanel.clear();\n      resultsPanel.add(ui.Label('Error calculating results: ' + e.message, {\n        color: 'red',\n        fontWeight: 'bold'\n      }));\n      print('Error in damage calculation:', e);\n    }\n  });\n}\n\n// Reanalyze with new POST_INTERVAL\nfunction reanalyzeWithNewInterval() {\n  // Clear console\n  //print('Reanalyzing: ' + POST_INTERVAL + ' months of war impact');\n  \n  // Update date range\n  var newDateRanges = updateDateRanges();\n  startDate = newDateRanges.startDate;\n  endDate = newDateRanges.endDate;\n  \n  //print('Analysis period: from ' + startDate + ' to ' + endDate);\n  \n  // Clear existing layers on map\n  while (Map.layers().length() &gt; 0) {\n    Map.layers().remove(Map.layers().get(0));\n  }\n  \n  // Recalculate building and road changes\n  var ascending_image = filter_s1(\"ASCENDING\");\n  var descending_image = filter_s1(\"DESCENDING\");\n  \nvar asc_des = ee.ImageCollection([ascending_image, descending_image])\n.median()\n.clip(aoi);\n\n// Add NDVI Mask\nvar s2 = ee.ImageCollection('COPERNICUS/S2_SR')\n.filterDate(startDate, SHOCK_DATE)\n.filterBounds(aoi)\n.select(['B4','B8'])\n.median();\nvar ndvi = s2.normalizedDifference(['B8','B4']).rename('NDVI');\nvar ndvi_mask = ndvi.gt(0.2);\n\n// Generate Composite Image\nvar composite_image = asc_des.where(ndvi_mask, 0);\n\n  // Create building change mask (95% confidence)\n  var threshold = composite_image.updateMask(composite_image.gt(0));\n\n  // Analyze building changes\n  damaged_building = threshold.reduceRegions({\n    collection: buildings,\n    reducer: ee.Reducer.mean(),\n    scale: 10\n  });\n\n  // Analyze road changes\n  damaged_roads = threshold.reduceRegions({\n    collection: roads,\n    reducer: ee.Reducer.mean(),\n    scale: 10\n  });\n  \n  // Number of affected buildings and roads\n  var mariupol_buildings = damaged_building.filterBounds(ukr1).filter(ee.Filter.gt(\"mean\", 0));\n  var kharkiv_buildings = damaged_building.filterBounds(ukr7).filter(ee.Filter.gt(\"mean\", 0));\n  var total_buildings = mariupol_buildings.merge(kharkiv_buildings);\n\n  var mariupol_roads = damaged_roads.filterBounds(ukr1).filter(ee.Filter.gt(\"mean\", 0.5));\n  var kharkiv_roads = damaged_roads.filterBounds(ukr7).filter(ee.Filter.gt(\"mean\", 0.5));\n  var total_roads = mariupol_roads.merge(kharkiv_roads);\n  \n  print(\"mariupol - damaged buildings:\", mariupol_buildings.size());\n  print(\"kharkiv - damaged buildings:\", kharkiv_buildings.size());\n  print(\"total - damaged buildings:\", total_buildings.size());\n  print(\"mariupol - damaged roads:\", mariupol_roads.size());\n  print(\"kharkiv - damaged roads:\", kharkiv_roads.size());\n  print(\"total - damaged roads:\", total_roads.size());\n  \n  // Draw building outlines\n  var empty_buildings = ee.Image().byte();\n  var buildings_outline = empty_buildings.paint({\n    featureCollection: damaged_building,\n    color: \"mean\",\n    width: 1.5\n  });\n\n  // Draw road outlines - add white border\n  var empty_roads = ee.Image().byte();\n  var roads_white_outline = empty_roads.paint({\n    featureCollection: damaged_roads,\n    color: 1,\n    width: 9\n  });\n  var roads_outline = empty_roads.paint({\n    featureCollection: damaged_roads,\n    color: \"mean\",\n    width: 5\n  });\n  \n  // Add layers\n  Map.addLayer(\n    composite_image,\n    { min: 0, max: 4, opacity: 0.8, palette: palette },\n    \"T-test Result\",\n    false\n  );\n\n  Map.addLayer(\n    buildings_outline,\n    { palette: building_palette, min: 0.6, max: 2 },\n    \"Damaged Buildings\",\n    true\n  );\n\n  Map.addLayer(\n    roads_white_outline,\n    { palette: [\"ffffff\"], min: 0, max: 1 },\n    \"Roads White Outline\",\n    false\n  );\n\n  Map.addLayer(\n    roads_outline,\n    { palette: building_palette, min: 0.6, max: 2 },\n    \"Damaged Roads\",\n    false\n  );\n\n  // Add city boundary layer\n  Map.addLayer(cityBoundaries, {}, 'adminboundaries');\n  \n  // Restore layer visibility state\n  updateLayerVisibility();\n  \n  // Reset results panel\n  updateResultsPanel();\n}\n\n// Update layer visibility state\nfunction updateLayerVisibility() {\n  // Set layer visibility based on checkbox state\n  var buildingsLayer = getLayerByName(\"Damaged Buildings\");\n  if (buildingsLayer) {\n    buildingsLayer.setShown(buildingsCheckbox.getValue());\n  }\n  \n  var whiteOutlineLayer = getLayerByName(\"Roads White Outline\");\n  var roadsLayer = getLayerByName(\"Damaged Roads\");\n  if (whiteOutlineLayer && roadsLayer) {\n    whiteOutlineLayer.setShown(roadsCheckbox.getValue());\n    roadsLayer.setShown(roadsCheckbox.getValue());\n  }\n  \n  var ttestLayer = getLayerByName(\"T-test Result\");\n  if (ttestLayer) {\n    ttestLayer.setShown(ttestCheckbox.getValue());\n  }\n}\n\n// -------------------------------------\n// Create download panel\nvar downloadPanel = ui.Panel({\n  layout: ui.Panel.Layout.flow('vertical'),\n  style: {stretch: 'horizontal', margin: '5px 0'}\n});\n\n// Add download title\ndownloadPanel.add(ui.Label('Download Damage Buildings Data', {\n  fontSize: '16px',\n  fontWeight: 'bold'\n}));\n\n// Label for displaying download link\nvar downloadUrlLabel = ui.Label(' ',{\n  fontSize: '13px'\n});\n\n// Create download button\nvar downloadButton = ui.Button({\n  label: 'Get Download Link',\n  onClick: function() {\n    // Get currently selected city\n    var selectedCity = citySelect.getValue();\n    \n    // Get corresponding AOI based on selected city\n    var cityAOI;\n    if (selectedCity === 'Mariupol') {\n      cityAOI = ukr1;\n    } else if (selectedCity === 'Kharkiv') {\n      cityAOI = ukr7;\n    }\n    \n    // Filter damaged buildings for current city\n    var city_buildings = damaged_building.filterBounds(cityAOI).filter(ee.Filter.gt(\"mean\", 0));\n    \n    // Generate current date-time string as part of filename\n    var filename = selectedCity + '_damaged_buildings_' + ee.Date(SHOCK_DATE).advance(POST_INTERVAL, \"month\").format('YYYY-MM-dd').getInfo();\n    \n    // Get download link\n    var url = city_buildings.getDownloadURL({\n      format: 'GeoJSON',\n      filename: filename\n    });\n    \n    // Update download link label\n    downloadUrlLabel.setUrl(url);\n    downloadUrlLabel.setValue('Download Link');\n    downloadUrlLabel.style().set({\n      fontSize: '13px',\n      color: 'blue',\n      textDecoration: 'underline'\n    });\n  },\n  style: {\n    stretch: 'horizontal',\n    textAlign: 'center',\n    margin: '5px 0'\n  }\n});\n\n// Add download button to download panel\ndownloadPanel.add(downloadButton);\ndownloadPanel.add(downloadUrlLabel);\n\n// -------------------------------------\n// Credit panel\nvar creditsNotes = ui.Panel([\n  ui.Label('Credits:', {fontSize: '12px', margin: '8px 8px 1px 8px', fontWeight: 'bold'}),\n  ui.Panel([\n    ui.Label('â€¢ Data source: ', {fontSize: '12px', margin: '0px 8px 8px 8px'}),\n    ui.Label('Sentinel-1', {fontSize: '12px', margin: '0px 8px 8px 0px'}, 'https://sentiwiki.copernicus.eu/web/s1-mission')\n  ], ui.Panel.Layout.flow('horizontal'), {margin: '0px 0px 0px 0px', padding: '0px 0px 0px 0px'}),\n  ui.Panel([\n    ui.Label('â€¢ Building Footprints: ', {fontSize: '12px', margin: '0px 8px 8px 8px'}),\n    ui.Label('Overture Maps Foundation', {fontSize: '12px', margin: '0px 8px 8px 0px'}, 'https://overturemaps.org/')\n  ], ui.Panel.Layout.flow('horizontal'), {margin: '0px 0px 0px 0px', padding: '0px 0px 0px 0px'}),\n  ui.Panel([\n    ui.Label('â€¢ Road Network: ', {fontSize: '12px', margin: '0px 8px 8px 8px'}),\n    ui.Label('OSM', {fontSize: '12px', margin: '0px 8px 8px 0px'}, 'https://www.openstreetmap.org/')\n  ], ui.Panel.Layout.flow('horizontal'), {margin: '0px 0px 0px 0px', padding: '0px 0px 0px 0px'})\n]);\n\n// Add all panels to left control panel\nleftPanel.add(titlePanel);\nleftPanel.add(lineBreak);\nleftPanel.add(cityPanel);\nleftPanel.add(timePanel);\nleftPanel.add(layerPanel);\nleftPanel.add(assessPanel);\nleftPanel.add(downloadPanel);\nleftPanel.add(creditsNotes);\n\n\n// Hide zoom button in top-left corner of map\nMap.setControlVisibility({zoomControl: false});\n\n// -------------------------------------\n// Comparison slider functionality\n// Create two map instances\nvar leftMap = ui.Map();  // Left map, showing analysis results\nvar rightMap = ui.Map();  // Right map, showing satellite imagery\n\n// Add left control panel to left map\nleftMap.add(leftPanel);\n\n// Set left map layers - copy all layers from original Map to leftMap\nfunction copyLayersToLeftMap() {\n  // First clear existing layers on leftMap\n  while (leftMap.layers().length() &gt; 0) {\n    leftMap.layers().remove(leftMap.layers().get(0));\n  }\n  \n  // Add building change layer\n  leftMap.addLayer(\n    composite_image,\n    { min: 0, max: 4, opacity: 0.8, palette: palette },\n    \"T-test Result\",\n    false  // Not displayed by default\n  );\n  \n  // Add building outline layer\n  leftMap.addLayer(\n    buildings_outline,\n    { palette: building_palette, min: 0.6, max: 2 },\n    \"Damaged Buildings\",\n    true  // Displayed by default\n  );\n  \n  // First add white border layer\n  leftMap.addLayer(\n    roads_white_outline,\n    { palette: [\"ffffff\"], min: 0, max: 1 },\n    \"Roads White Outline\",\n    false  // Not displayed by default\n  );\n  \n  // Then add colored road layer\n  leftMap.addLayer(\n    roads_outline,\n    { palette: building_palette, min: 0.6, max: 2 },\n    \"Damaged Roads\",\n    false  // Not displayed by default\n  );\n  \n  // Add city boundary layer\n  leftMap.addLayer(cityBoundaries, {}, 'adminboundaries');\n  \n  // Restore layer visibility state\n  updateLeftMapLayerVisibility();\n}\n\n// Update left map layer visibility\nfunction updateLeftMapLayerVisibility() {\n  // Set layer visibility based on checkbox state\n  var buildingsLayer = getLeftMapLayerByName(\"Damaged Buildings\");\n  if (buildingsLayer) {\n    buildingsLayer.setShown(buildingsCheckbox.getValue());\n  }\n  \n  var whiteOutlineLayer = getLeftMapLayerByName(\"Roads White Outline\");\n  var roadsLayer = getLeftMapLayerByName(\"Damaged Roads\");\n  if (whiteOutlineLayer && roadsLayer) {\n    whiteOutlineLayer.setShown(roadsCheckbox.getValue());\n    roadsLayer.setShown(roadsCheckbox.getValue());\n  }\n  \n  var ttestLayer = getLeftMapLayerByName(\"T-test Result\");\n  if (ttestLayer) {\n    ttestLayer.setShown(ttestCheckbox.getValue());\n  }\n}\n\n// Get left map specific layer name\nfunction getLeftMapLayerByName(name) {\n  var layers = leftMap.layers().getJsArray();\n  for (var i = 0; i &lt; layers.length; i++) {\n    if (layers[i].getName() === name) {\n      return layers[i];\n    }\n  }\n  return null;\n}\n\n// Set right map layers - show satellite imagery\nfunction setRightMapLayers() {\n  // First clear existing layers on rightMap\n  while (rightMap.layers().length() &gt; 0) {\n    rightMap.layers().remove(rightMap.layers().get(0));\n  }\n  \n  // Set satellite base map\n  rightMap.setOptions('HYBRID');\n  \n  // Add building footprint (white outline)\n  var emptyBuildings = ee.Image().byte();\n  var buildingsOutlineWhite = emptyBuildings.paint({\n    featureCollection: damaged_building,\n    color: 1,\n    width: 1.5\n  });\n  \n  rightMap.addLayer(\n    buildingsOutlineWhite,\n    {palette: ['white'], min: 0, max: 1, opacity: 0.7},\n    'Buildings Footprint',\n    true\n  );\n}\n\n// Initialize left and right maps\ncopyLayersToLeftMap();\nsetRightMapLayers();\n\n// Set initial center position\nleftMap.centerObject(mariupolCenter, 14);\nrightMap.centerObject(mariupolCenter, 14);\n\n// Create map linker to synchronize two maps\nvar linker = ui.Map.Linker([leftMap, rightMap]);\n\n// Modify city selection dropdown onChange event, update both maps\ncitySelect.onChange(function(value) {\n  // Get current city center\n  var cityCenter;\n  var zoomLevel;\n  \n  if (value === 'Kharkiv') {\n    cityCenter = kharkivCenter;\n    zoomLevel = 13;\n  } else { // Mariupol\n    cityCenter = mariupolCenter;\n    zoomLevel = 14;\n  }\n  \n  // Update center position of both maps\n  leftMap.centerObject(cityCenter, zoomLevel);\n  rightMap.centerObject(cityCenter, zoomLevel);\n  \n  // Update right map\n  setRightMapLayers();\n});\n\n// Modify layer checkbox onChange event to update left map\nbuildingsCheckbox.onChange(function(isChecked) {\n  var layer = getLeftMapLayerByName(\"Damaged Buildings\");\n  if (layer) {\n    layer.setShown(isChecked);\n  }\n});\n\nroadsCheckbox.onChange(function(isChecked) {\n  var whiteOutline = getLeftMapLayerByName(\"Roads White Outline\");\n  var roads = getLeftMapLayerByName(\"Damaged Roads\");\n  \n  if (whiteOutline) {\n    whiteOutline.setShown(isChecked);\n  }\n  \n  if (roads) {\n    roads.setShown(isChecked);\n  }\n});\n\nttestCheckbox.onChange(function(isChecked) {\n  var layer = getLeftMapLayerByName(\"T-test Result\");\n  if (layer) {\n    layer.setShown(isChecked);\n  }\n});\n\n// Create split panel\nvar splitPanel = ui.SplitPanel({\n  firstPanel: leftMap,\n  secondPanel: rightMap,\n  orientation: 'horizontal',\n  wipe: true,\n  style: {stretch: 'both'}\n});\n\n// Add split panel to UI root widget\nui.root.widgets().reset([splitPanel]);\n\n// ensure that each initialization starts from 2022-3-24\nreanalyzeWithNewInterval();"
  },
  {
    "objectID": "index.html#reference",
    "href": "index.html#reference",
    "title": "Assessing Urban War Damage in Kharkiv and Mariupol, Ukraine Using Sentinel-1 Imagery",
    "section": "",
    "text": "Ballinger, O. (2024) 9 Blast Damage Assessment (WWW) London: CASA (https://github.com/oballinger/CASA0025/; 12 Mar 2024).\nDietrich, O., Peters, T., Sainte Fare Garnot, V. and others (2025) An open-source tool for mapping war destruction at scale in Ukraine using Sentinel-1 time series, Communications Earth & Environment, 6, 215. Available at: https://doi.org/10.1038/s43247-025-02183-7 [Accessed 27 April 2025].\nUSGS, 2018. NDVI: The Foundation of Remote Sensing Phenology. [online] Available at: https://www.usgs.gov/special-topics/remote-sensing-phenology/science/ndvi-foundation-remote-sensing-phenology [Accessed 27 April 2025].\nWang, X. and Li, P. (2020) Extraction of urban building damage using spectral, height and corner information from VHR satellite images and airborne LiDAR data, ISPRS Journal of Photogrammetry and Remote Sensing, 159."
  },
  {
    "objectID": "Data collection and processing/road_download_buffer.html",
    "href": "Data collection and processing/road_download_buffer.html",
    "title": "1. Download data",
    "section": "",
    "text": "# Download osmnx package\n#pip install osmnx\n\nRequirement already satisfied: osmnx in /opt/conda/lib/python3.11/site-packages (2.0.2)\nRequirement already satisfied: geopandas&gt;=1.0 in /opt/conda/lib/python3.11/site-packages (from osmnx) (1.0.1)\nRequirement already satisfied: networkx&gt;=2.5 in /opt/conda/lib/python3.11/site-packages (from osmnx) (3.3)\nRequirement already satisfied: numpy&gt;=1.22 in /opt/conda/lib/python3.11/site-packages (from osmnx) (1.26.4)\nRequirement already satisfied: pandas&gt;=1.4 in /opt/conda/lib/python3.11/site-packages (from osmnx) (2.2.2)\nRequirement already satisfied: requests&gt;=2.27 in /opt/conda/lib/python3.11/site-packages (from osmnx) (2.32.3)\nRequirement already satisfied: shapely&gt;=2.0 in /opt/conda/lib/python3.11/site-packages (from osmnx) (2.0.6)\nRequirement already satisfied: pyogrio&gt;=0.7.2 in /opt/conda/lib/python3.11/site-packages (from geopandas&gt;=1.0-&gt;osmnx) (0.9.0)\nRequirement already satisfied: packaging in /opt/conda/lib/python3.11/site-packages (from geopandas&gt;=1.0-&gt;osmnx) (24.1)\nRequirement already satisfied: pyproj&gt;=3.3.0 in /opt/conda/lib/python3.11/site-packages (from geopandas&gt;=1.0-&gt;osmnx) (3.6.1)\nRequirement already satisfied: python-dateutil&gt;=2.8.2 in /opt/conda/lib/python3.11/site-packages (from pandas&gt;=1.4-&gt;osmnx) (2.9.0)\nRequirement already satisfied: pytz&gt;=2020.1 in /opt/conda/lib/python3.11/site-packages (from pandas&gt;=1.4-&gt;osmnx) (2024.1)\nRequirement already satisfied: tzdata&gt;=2022.7 in /opt/conda/lib/python3.11/site-packages (from pandas&gt;=1.4-&gt;osmnx) (2024.1)\nRequirement already satisfied: charset-normalizer&lt;4,&gt;=2 in /opt/conda/lib/python3.11/site-packages (from requests&gt;=2.27-&gt;osmnx) (3.3.2)\nRequirement already satisfied: idna&lt;4,&gt;=2.5 in /opt/conda/lib/python3.11/site-packages (from requests&gt;=2.27-&gt;osmnx) (3.8)\nRequirement already satisfied: urllib3&lt;3,&gt;=1.21.1 in /opt/conda/lib/python3.11/site-packages (from requests&gt;=2.27-&gt;osmnx) (2.2.2)\nRequirement already satisfied: certifi&gt;=2017.4.17 in /opt/conda/lib/python3.11/site-packages (from requests&gt;=2.27-&gt;osmnx) (2024.8.30)\nRequirement already satisfied: six&gt;=1.5 in /opt/conda/lib/python3.11/site-packages (from python-dateutil&gt;=2.8.2-&gt;pandas&gt;=1.4-&gt;osmnx) (1.16.0)\nNote: you may need to restart the kernel to use updated packages.\n# import packages\nimport geopandas as gpd\nimport os\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom shapely.geometry import Polygon, LineString\nimport math\nimport networkx as nx\nimport osmnx as ox\nuse the same method for ukr7\n# download data\ntry:\n    G_ukr1 = ox.graph.graph_from_place(\"Mariupol, Ukraine\", network_type=\"drive\", simplify=True)\n    G_ukr1 = G_ukr1.to_undirected()  \n    print(\"success, num of nodes:\", len(G_ukr1.nodes))\nexcept Exception as e:\n    print(f\"fails: {e}\")\n\nsuccess, num of nodes: 3975\n# check the graph\nfig, ax = ox.plot_graph(G_ukr1)\n# transform to geodataframe\ngdf_nodes_ukr1, gdf_edges_urk1 = ox.graph_to_gdfs(G_ukr1)\nfields_to_save = ['osmid', 'highway', 'lanes', 'maxspeed', 'name', 'oneway', 'ref',\n       'reversed', 'length', 'geometry', 'bridge', 'junction', 'tunnel',\n       'access', 'width']\n#gdf_edges_urk1[fields_to_save].to_file(\"osm_ukr1_py_unclean.shp\", driver=\"ESRI Shapefile\")\n# check columns\nprint(gdf_edges_urk1.columns)\n\nIndex(['osmid', 'highway', 'lanes', 'maxspeed', 'name', 'oneway', 'ref',\n       'reversed', 'length', 'geometry', 'bridge', 'junction', 'tunnel',\n       'access', 'width'],\n      dtype='object')\n# check null values\nprint(gdf_edges_urk1['highway'].isnull().sum()) \n\n0\n# check index and found that \"v\" & \"u\"are the index\nprint(gdf_edges_urk1.index)\n\nMultiIndex([(   84519135,  1192542079, 0),\n            (   84519135,  1195420407, 0),\n            (   84519135,  1194078849, 0),\n            (   84519135,  9076033095, 0),\n            (   84519141,  5584129684, 0),\n            (   84519141,  1844212931, 0),\n            (   84519141,  1194261491, 0),\n            (   84519143,  3732128706, 0),\n            (   84519143,  1193943710, 0),\n            (   84519143,  1844212933, 0),\n            ...\n            ( 9077192694,  9105638545, 0),\n            ( 9225071013,  9225071014, 0),\n            ( 9225071013,  9225090528, 0),\n            ( 9225071013,  9225090529, 0),\n            ( 9225071014,  9225090521, 0),\n            ( 9225090521,  9225090529, 0),\n            ( 9225090529,  9225090530, 0),\n            ( 9492824162,  9492824163, 0),\n            (11999186892, 11999186906, 0),\n            (11999186907, 11999186910, 0)],\n           names=['u', 'v', 'key'], length=6035)\n# reset index\ngdf_edges_urk1 = gdf_edges_urk1.reset_index()\n# set u & v are columns\nprint(gdf_edges_urk1.columns)\n\nIndex(['u', 'v', 'key', 'osmid', 'highway', 'lanes', 'maxspeed', 'name',\n       'oneway', 'ref', 'reversed', 'length', 'geometry', 'bridge', 'junction',\n       'tunnel', 'access', 'width'],\n      dtype='object')"
  },
  {
    "objectID": "Data collection and processing/road_download_buffer.html#data-cleaning",
    "href": "Data collection and processing/road_download_buffer.html#data-cleaning",
    "title": "1. Download data",
    "section": "2. Data Cleaning",
    "text": "2. Data Cleaning\n\n# extract edges\n#osm_ukr1_py = gpd.read_file('osm_ukr1_py_unclean.shp')\nosm_ukr1_py = gdf_edges_urk1.copy()\nprint(osm_ukr1_py.columns)\nprint(osm_ukr1_py.shape)\n\nIndex(['u', 'v', 'key', 'osmid', 'highway', 'lanes', 'maxspeed', 'name',\n       'oneway', 'ref', 'reversed', 'length', 'geometry', 'bridge', 'junction',\n       'tunnel', 'access', 'width'],\n      dtype='object')\n(6035, 18)\n\n\n\n# plot it \nosm_ukr1_py.plot()\n\n\n\n\n\n\n\n\n\n# select major roads\nmajor_road_types = [\n    \"trunk\", \"trunk_link\",\n    \"primary\", \"primary_link\",\n    \"secondary\",\"secondary_link\",\n    \"tertiary\",\"tertiary_link\"\n]\nosm_ukr1_py = osm_ukr1_py[osm_ukr1_py['highway'].isin(major_road_types)].copy()\nosm_ukr1_py\n\n\n\n\n\n\n\n\nu\nv\nkey\nosmid\nhighway\nlanes\nmaxspeed\nname\noneway\nref\nreversed\nlength\ngeometry\nbridge\njunction\ntunnel\naccess\nwidth\n\n\n\n\n0\n84519135\n1192542079\n0\n38939561\ntrunk\n1\n50\nÐ¨ÐµÐ²Ñ‡ÐµÐ½ÐºÐ° Ð±ÑƒÐ»ÑŒÐ²Ð°Ñ€\nTrue\nÐœ-14\nFalse\n180.396484\nLINESTRING (37.56465 47.10446, 37.56445 47.104...\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1\n84519135\n1195420407\n0\n91291242\ntertiary\n2\n50\nÐ¢Ð¾Ñ€Ð³Ð¾Ð²Ð° Ð²ÑƒÐ»Ð¸Ñ†Ñ\nFalse\nNaN\nTrue\n168.223144\nLINESTRING (37.56536 47.10586, 37.56492 47.105...\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n2\n84519135\n1194078849\n0\n399366618\nsecondary\n3\n50\nÐ¢Ð¾Ñ€Ð³Ð¾Ð²Ð° Ð²ÑƒÐ»Ð¸Ñ†Ñ\nFalse\nNaN\nFalse\n11.067169\nLINESTRING (37.56457 47.10438, 37.5646 47.1044...\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n3\n84519135\n9076033095\n0\n[478343683, 103407203, 202280230, 103407207, 1...\ntrunk\n1\n50\nÐŸÐ¾ÑÑ‚-Ð¼Ñ–ÑÑ‚\nTrue\nÐœ-14\nFalse\n732.245662\nLINESTRING (37.57281 47.10108, 37.57277 47.101...\nyes\nNaN\nNaN\nNaN\nNaN\n\n\n4\n84519141\n5584129684\n0\n422801739\nsecondary\n2\n50\nÐ¢Ð¾Ñ€Ð³Ð¾Ð²Ð° Ð²ÑƒÐ»Ð¸Ñ†Ñ\nFalse\nNaN\nFalse\n13.141065\nLINESTRING (37.56167 47.09751, 37.56166 47.09739)\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n6025\n9077192694\n9105638545\n0\n[981300114, 981181525]\ntrunk\n4\n40\nÐÐ°Ð±ÐµÑ€ÐµÐ¶Ð½Ð° Ð²ÑƒÐ»Ð¸Ñ†Ñ\nFalse\nÐœ-14\nTrue\n578.364448\nLINESTRING (37.60658 47.11265, 37.60817 47.113...\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n6027\n9225071013\n9225090528\n0\n999238329\ntertiary\n2\n50\nNaN\nTrue\nNaN\nFalse\n8.835340\nLINESTRING (37.55382 47.11332, 37.5538 47.1133...\nNaN\nroundabout\nNaN\nNaN\nNaN\n\n\n6028\n9225071013\n9225090529\n0\n999238329\ntertiary\n2\n50\nNaN\nTrue\nNaN\nFalse\n9.731612\nLINESTRING (37.55394 47.11335, 37.55391 47.113...\nNaN\nroundabout\nNaN\nNaN\nNaN\n\n\n6030\n9225090521\n9225090529\n0\n264429540\ntertiary\n3\n50\nÐšÐ°Ñ€Ð¿Ñ–Ð½ÑÑŒÐºÐ¾Ð³Ð¾ Ð²ÑƒÐ»Ð¸Ñ†Ñ\nFalse\nÐ-20\nTrue\n25.960095\nLINESTRING (37.554 47.11358, 37.55394 47.11335)\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n6031\n9225090529\n9225090530\n0\n999238330\ntertiary\n2\n50\nNaN\nTrue\nNaN\nFalse\n17.277432\nLINESTRING (37.55407 47.11324, 37.55407 47.113...\nNaN\nroundabout\nNaN\nNaN\nNaN\n\n\n\n\n1546 rows Ã— 18 columns\n\n\n\n\n# plot it \nosm_ukr1_py.plot()\n\n\n\n\n\n\n\n\n\n# use u & v to remove bidirectional roads\ndef remove_bidirectional_duplicates(df: pd.DataFrame) -&gt; pd.DataFrame:\n    assert all(col in df.columns for col in ['u', 'v']), \"DataFrame must contain 'u' and 'v' \"\n\n    df = df.copy().reset_index(drop=True) \n    df['pair'] = 0\n\n    processed = [False] * len(df)\n    pair_id = 1\n\n    for i in range(len(df)):\n        if not processed[i]:\n            found = False\n            u_i, v_i = df.at[i, 'u'], df.at[i, 'v']\n\n            for j in range(i + 1, len(df)):\n                if not processed[j]:\n                    u_j, v_j = df.at[j, 'u'], df.at[j, 'v']\n\n                    if u_i == v_j and v_i == u_j:\n                        df.at[i, 'pair'] = pair_id\n                        df.at[j, 'pair'] = pair_id\n                        processed[i] = processed[j] = True\n                        pair_id += 1\n                        found = True\n                        break\n\n            if not found:\n                df.at[i, 'pair'] = pair_id\n                processed[i] = True\n                pair_id += 1\n\n    df['pair'] = df['pair'].astype(int)\n    df_unique = df.drop_duplicates(subset='pair', keep='first').reset_index(drop=True)\n    return df_unique\n\n\nosm_ukr1_py = remove_bidirectional_duplicates(osm_ukr1_py)\nprint(osm_ukr1_py.shape)\n\n(1546, 19)\n\n\n\nosm_ukr1_py\n\n\n\n\n\n\n\n\nu\nv\nkey\nosmid\nhighway\nlanes\nmaxspeed\nname\noneway\nref\nreversed\nlength\ngeometry\nbridge\njunction\ntunnel\naccess\nwidth\npair\n\n\n\n\n0\n84519135\n1192542079\n0\n38939561\ntrunk\n1\n50\nÐ¨ÐµÐ²Ñ‡ÐµÐ½ÐºÐ° Ð±ÑƒÐ»ÑŒÐ²Ð°Ñ€\nTrue\nÐœ-14\nFalse\n180.396484\nLINESTRING (37.56465 47.10446, 37.56445 47.104...\nNaN\nNaN\nNaN\nNaN\nNaN\n1\n\n\n1\n84519135\n1195420407\n0\n91291242\ntertiary\n2\n50\nÐ¢Ð¾Ñ€Ð³Ð¾Ð²Ð° Ð²ÑƒÐ»Ð¸Ñ†Ñ\nFalse\nNaN\nTrue\n168.223144\nLINESTRING (37.56536 47.10586, 37.56492 47.105...\nNaN\nNaN\nNaN\nNaN\nNaN\n2\n\n\n2\n84519135\n1194078849\n0\n399366618\nsecondary\n3\n50\nÐ¢Ð¾Ñ€Ð³Ð¾Ð²Ð° Ð²ÑƒÐ»Ð¸Ñ†Ñ\nFalse\nNaN\nFalse\n11.067169\nLINESTRING (37.56457 47.10438, 37.5646 47.1044...\nNaN\nNaN\nNaN\nNaN\nNaN\n3\n\n\n3\n84519135\n9076033095\n0\n[478343683, 103407203, 202280230, 103407207, 1...\ntrunk\n1\n50\nÐŸÐ¾ÑÑ‚-Ð¼Ñ–ÑÑ‚\nTrue\nÐœ-14\nFalse\n732.245662\nLINESTRING (37.57281 47.10108, 37.57277 47.101...\nyes\nNaN\nNaN\nNaN\nNaN\n4\n\n\n4\n84519141\n5584129684\n0\n422801739\nsecondary\n2\n50\nÐ¢Ð¾Ñ€Ð³Ð¾Ð²Ð° Ð²ÑƒÐ»Ð¸Ñ†Ñ\nFalse\nNaN\nFalse\n13.141065\nLINESTRING (37.56167 47.09751, 37.56166 47.09739)\nNaN\nNaN\nNaN\nNaN\nNaN\n5\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n1541\n9077192694\n9105638545\n0\n[981300114, 981181525]\ntrunk\n4\n40\nÐÐ°Ð±ÐµÑ€ÐµÐ¶Ð½Ð° Ð²ÑƒÐ»Ð¸Ñ†Ñ\nFalse\nÐœ-14\nTrue\n578.364448\nLINESTRING (37.60658 47.11265, 37.60817 47.113...\nNaN\nNaN\nNaN\nNaN\nNaN\n1542\n\n\n1542\n9225071013\n9225090528\n0\n999238329\ntertiary\n2\n50\nNaN\nTrue\nNaN\nFalse\n8.835340\nLINESTRING (37.55382 47.11332, 37.5538 47.1133...\nNaN\nroundabout\nNaN\nNaN\nNaN\n1543\n\n\n1543\n9225071013\n9225090529\n0\n999238329\ntertiary\n2\n50\nNaN\nTrue\nNaN\nFalse\n9.731612\nLINESTRING (37.55394 47.11335, 37.55391 47.113...\nNaN\nroundabout\nNaN\nNaN\nNaN\n1544\n\n\n1544\n9225090521\n9225090529\n0\n264429540\ntertiary\n3\n50\nÐšÐ°Ñ€Ð¿Ñ–Ð½ÑÑŒÐºÐ¾Ð³Ð¾ Ð²ÑƒÐ»Ð¸Ñ†Ñ\nFalse\nÐ-20\nTrue\n25.960095\nLINESTRING (37.554 47.11358, 37.55394 47.11335)\nNaN\nNaN\nNaN\nNaN\nNaN\n1545\n\n\n1545\n9225090529\n9225090530\n0\n999238330\ntertiary\n2\n50\nNaN\nTrue\nNaN\nFalse\n17.277432\nLINESTRING (37.55407 47.11324, 37.55407 47.113...\nNaN\nroundabout\nNaN\nNaN\nNaN\n1546\n\n\n\n\n1546 rows Ã— 19 columns\n\n\n\n\n#osm_ukr1_py.to_file(\"osm_ukr1_py_pri_clean.geojson\", driver=\"GeoJSON\")\n\n\n#osm_ukr1_py = gpd.read_file('osm_ukr1_py_pri_clean.geojson')\nprint(osm_ukr1_py.columns)\nprint(osm_ukr1_py.shape)\n\nIndex(['u', 'v', 'key', 'osmid', 'highway', 'lanes', 'maxspeed', 'name',\n       'oneway', 'ref', 'reversed', 'length', 'geometry', 'bridge', 'junction',\n       'tunnel', 'access', 'width', 'pair'],\n      dtype='object')\n(1546, 19)\n\n\n\nosm_ukr1_py.plot()\n\n\n\n\n\n\n\n\n\n# reproject\nosm_ukr1 = osm_ukr1_py.to_crs(\"EPSG:6385\")\n\n\nosm_ukr1.plot()\n\n\n\n\n\n\n\n\n\n# plot to check the length distribution\nimport seaborn as sns\n\nprint(osm_ukr1['length'].describe())\n\nplt.figure(figsize=(10, 5))\nsns.histplot(osm_ukr1['length'], bins=50, kde=True)\nplt.title(\"Length\")\nplt.xlabel(\"meter\")\nplt.ylabel(\"frequency\")\nplt.grid(True)\nplt.show()\n\ncount    1546.000000\nmean      166.025433\nstd       220.648865\nmin         2.052115\n25%        47.143844\n50%       102.327948\n75%       209.174361\nmax      2602.992423\nName: length, dtype: float64\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#cut roads function\nfrom shapely.geometry import LineString\nfrom shapely.ops import substring\ndef segment_roads_by_length(geodf, segment_length):\n    from shapely.ops import substring\n    segmented_features = []\n\n    geodf = geodf.explode(ignore_index=True)\n\n    for idx, road in geodf.iterrows():\n        geom = road.geometry\n\n        if geom is None or geom.is_empty or geom.geom_type != 'LineString':\n            continue\n\n        total_length = geom.length\n        split_distances = np.arange(0, total_length, segment_length)\n        split_distances = np.append(split_distances, total_length)\n\n        for i in range(len(split_distances) - 1):\n            start = split_distances[i]\n            end = split_distances[i + 1]\n            try:\n                segment_geom = substring(geom, start, end)\n                if segment_geom.is_empty:\n                    continue\n                new_feature = road.to_dict()\n                new_feature['geometry'] = segment_geom\n                new_feature['segment_id'] = f\"{idx}_{i}\"\n                new_feature['segment_length'] = segment_geom.length\n                segmented_features.append(new_feature)\n            except Exception as e:\n                print(f\"[!] Error segmenting line {idx} segment {i}: {e}\")\n                continue\n\n    return gpd.GeoDataFrame(segmented_features, crs=geodf.crs)\n\n\n# cut by 100 meters\nosm_ukr1 = segment_roads_by_length(osm_ukr1, 100)\nprint(osm_ukr1.shape)\n\n(3392, 21)\n\n\n\n# check the length distribution\nprint(osm_ukr1['segment_length'].describe())\n\nplt.figure(figsize=(10, 5))\nsns.histplot(osm_ukr1['segment_length'], bins=50, kde=True)\nplt.title(\"Length\")\nplt.xlabel(\"meter\")\nplt.ylabel(\"frequency\")\nplt.grid(True)\nplt.show()\n\ncount    3392.000000\nmean       75.890174\nstd        32.905888\nmin         0.119698\n25%        52.021736\n50%       100.000000\n75%       100.000000\nmax       100.000000\nName: segment_length, dtype: float64\n\n\n\n\n\n\n\n\n\n\nosm_ukr1['length_new'] = osm_ukr1.geometry.length\n\n\nosm_ukr1\n\n\n\n\n\n\n\n\nu\nv\nkey\nosmid\nhighway\nlanes\nmaxspeed\nname\noneway\nref\n...\nbridge\njunction\ntunnel\naccess\nwidth\npair\ngeometry\nsegment_id\nsegment_length\nlength_new\n\n\n\n\n0\n84519135\n1192542079\n0\n38939561\ntrunk\n1\n50\nÐ¨ÐµÐ²Ñ‡ÐµÐ½ÐºÐ° Ð±ÑƒÐ»ÑŒÐ²Ð°Ñ€\nTrue\nÐœ-14\n...\nNaN\nNaN\nNaN\nNaN\nNaN\n1\nLINESTRING (646580.464 5229088.86, 646564.933 ...\n0_0\n100.000000\n100.000000\n\n\n1\n84519135\n1192542079\n0\n38939561\ntrunk\n1\n50\nÐ¨ÐµÐ²Ñ‡ÐµÐ½ÐºÐ° Ð±ÑƒÐ»ÑŒÐ²Ð°Ñ€\nTrue\nÐœ-14\n...\nNaN\nNaN\nNaN\nNaN\nNaN\n1\nLINESTRING (646493.566 5229138.302, 646422.6 5...\n0_1\n81.026379\n81.026379\n\n\n2\n84519135\n1195420407\n0\n91291242\ntertiary\n2\n50\nÐ¢Ð¾Ñ€Ð³Ð¾Ð²Ð° Ð²ÑƒÐ»Ð¸Ñ†Ñ\nFalse\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\n2\nLINESTRING (646625.831 5229247.34, 646594.914 ...\n1_0\n100.000000\n100.000000\n\n\n3\n84519135\n1195420407\n0\n91291242\ntertiary\n2\n50\nÐ¢Ð¾Ñ€Ð³Ð¾Ð²Ð° Ð²ÑƒÐ»Ð¸Ñ†Ñ\nFalse\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\n2\nLINESTRING (646586.522 5229157.105, 646583.498...\n1_1\n68.512741\n68.512741\n\n\n4\n84519135\n1194078849\n0\n399366618\nsecondary\n3\n50\nÐ¢Ð¾Ñ€Ð³Ð¾Ð²Ð° Ð²ÑƒÐ»Ð¸Ñ†Ñ\nFalse\nNaN\n...\nNaN\nNaN\nNaN\nNaN\nNaN\n3\nLINESTRING (646575.131 5229079.135, 646577.127...\n2_0\n11.091049\n11.091049\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n3387\n9077192694\n9105638545\n0\n[981300114, 981181525]\ntrunk\n4\n40\nÐÐ°Ð±ÐµÑ€ÐµÐ¶Ð½Ð° Ð²ÑƒÐ»Ð¸Ñ†Ñ\nFalse\nÐœ-14\n...\nNaN\nNaN\nNaN\nNaN\nNaN\n1542\nLINESTRING (650087.864 5230499.888, 650109.944...\n1541_5\n80.233034\n80.233034\n\n\n3388\n9225071013\n9225090528\n0\n999238329\ntertiary\n2\n50\nNaN\nTrue\nNaN\n...\nNaN\nroundabout\nNaN\nNaN\nNaN\n1543\nLINESTRING (645701.813 5230025.81, 645700.365 ...\n1542_0\n8.853104\n8.853104\n\n\n3389\n9225071013\n9225090529\n0\n999238329\ntertiary\n2\n50\nNaN\nTrue\nNaN\n...\nNaN\nroundabout\nNaN\nNaN\nNaN\n1544\nLINESTRING (645710.783 5230028.92, 645708.34 5...\n1543_0\n9.770713\n9.770713\n\n\n3390\n9225090521\n9225090529\n0\n264429540\ntertiary\n3\n50\nÐšÐ°Ñ€Ð¿Ñ–Ð½ÑÑŒÐºÐ¾Ð³Ð¾ Ð²ÑƒÐ»Ð¸Ñ†Ñ\nFalse\nÐ-20\n...\nNaN\nNaN\nNaN\nNaN\nNaN\n1545\nLINESTRING (645713.492 5230054.774, 645710.783...\n1544_0\n25.995254\n25.995254\n\n\n3391\n9225090529\n9225090530\n0\n999238330\ntertiary\n2\n50\nNaN\nTrue\nNaN\n...\nNaN\nroundabout\nNaN\nNaN\nNaN\n1546\nLINESTRING (645721.084 5230017.042, 645720.863...\n1545_0\n17.321810\n17.321810\n\n\n\n\n3392 rows Ã— 22 columns\n\n\n\n\n# clip by aoi boundary \naoi_ukr1 = gpd.read_file(\"./data/unosat_aois.geojson\") # import aoi of ukr1 \nprint(aoi_ukr1.crs)\nprint(osm_ukr1.crs)\nosm = osm_ukr1.copy().to_crs(epsg=4326)\nosm_ukr1_2 = gpd.clip(osm,aoi_ukr1)\nprint(osm_ukr1.shape)\nosm_ukr1_2.plot()\n\nEPSG:4326\nEPSG:6385\n(3392, 22)\n\n\n\n\n\n\n\n\n\n\nprint(osm_ukr1_2.shape)\n\n(1506, 22)\n\n\n\n# check it again\nplt.figure(figsize=(10, 6))\nplt.hist(osm_ukr1_2['length_new'], bins=50, color='skyblue', edgecolor='black')\nplt.title(\"Distribution of Polyline Lengths\")\nplt.xlabel(\"Length (meters)\")\nplt.ylabel(\"Frequency\")\nplt.grid(True)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\nosm_ukr1_3 = osm_ukr1_2.copy().to_crs(epsg=6385)\n\n\n# create buffer\nfrom shapely.geometry import LineString, Polygon\nimport math\n\ndef create_rectangles_from_lines(geodf, offset=2.5):   \n    def create_rect_from_segment(segment, offset):\n        if not isinstance(segment, LineString) or len(segment.coords) &lt; 2:\n            return None\n        \n        coords = list(segment.coords)\n        p_start = coords[0]\n        p_end = coords[-1]\n        \n        dx = p_end[0] - p_start[0]\n        dy = p_end[1] - p_start[1]\n        seg_len = math.hypot(dx, dy)\n        if seg_len == 0:\n            return None\n\n        ux = -dy / seg_len\n        uy = dx / seg_len\n\n        p1 = (p_start[0] + ux * offset, p_start[1] + uy * offset) \n        p2 = (p_end[0] + ux * offset, p_end[1] + uy * offset)      \n        p3 = (p_end[0] - ux * offset, p_end[1] - uy * offset)      \n        p4 = (p_start[0] - ux * offset, p_start[1] - uy * offset)  \n        \n        return Polygon([p1, p2, p3, p4])\n\n    geodf[\"rect_polygon\"] = geodf[\"geometry\"].apply(lambda seg: create_rect_from_segment(seg, offset))\n    \n    return geodf\n\n\n# create buffer\nosm_ukr1_buffer = create_rectangles_from_lines(osm_ukr1_3, offset=3.75)\nprint(osm_ukr1_buffer.shape)\n\n(1506, 23)\n\n\n\n# save as shp\n\nosm_ukr1_buffer = gpd.GeoDataFrame(osm_ukr1_buffer[['rect_polygon']].copy(),\n                            geometry='rect_polygon',\n                            crs=osm_ukr1_buffer.crs)\n\nosm_ukr1_buffer = osm_ukr1_buffer.rename(columns={'rect_polygon':'geometry'})\nosm_ukr1_buffer = osm_ukr1_buffer.set_geometry('geometry')\n\nprint(osm_ukr1_buffer.shape)\n\n#gdf_rect.to_file(\"gdf_rect_10_2.shp\", driver=\"ESRI Shapefile\")\n\n(1506, 1)\n\n\n\nprint(osm_ukr1_buffer.crs)\n\nEPSG:6385\n\n\n\n# adjust for gee\nfrom shapely.affinity import translate\nosm_ukr1_buffer_2 = osm_ukr1_buffer.copy()\nosm_ukr1_buffer_2['geometry'] = osm_ukr1_buffer_2['geometry'].apply(\n    lambda geom: translate(geom, xoff=-110, yoff=-15)\n)\n\n\nosm_ukr1_buffer_2.plot()\n\n\n\n\n\n\n\n\n\n#osm_ukr1_buffer_2.to_file(\"osm_ukr1_buffer_50_75_8.shp\", driver=\"ESRI Shapefile\")"
  }
]